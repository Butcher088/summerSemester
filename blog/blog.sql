/*
 Navicat Premium Data Transfer

 Source Server         : 腾讯云
 Source Server Type    : MySQL
 Source Server Version : 80024
 Source Host           : 1.117.168.162:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80024
 File Encoding         : 65001

 Date: 29/07/2022 00:52:42
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `article_id` int(0) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `user_id` int(0) NOT NULL COMMENT '发布人',
  `create_time` datetime(0) NOT NULL COMMENT '发布日期',
  `html_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'html格式文章内容',
  `title` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章标题',
  `comment_count` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `like_count` int(0) NULL DEFAULT 0 COMMENT '点赞数',
  `collect_count` int(0) NULL DEFAULT 0 COMMENT '收藏数',
  `click_count` int(0) NULL DEFAULT 0 COMMENT '浏览量',
  `edit_time` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '编辑时间',
  `md_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT 'md格式文章内容',
  `summary` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '文章摘要',
  `cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章封面',
  PRIMARY KEY (`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 133 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (26, 3, '2022-07-19 01:12:24', '<p>就在前两天，一篇反对<strong>Vue2</strong>升级到<strong>Vue3</strong>的文章在vue官方社区引起了热议。（原文链接：<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fjs-dojo%2Fvue-3-was-a-mistake-that-we-should-not-repeat-81cc65484954\" target=\"_blank\">Vue 3 was a mistake that we should not repeat</a>）</p>\n<p>这篇文章从<strong>实际应用</strong>角度出发，分析了<strong>Vue2</strong>到<strong>Vue3</strong>在真实项目中实操升级的<strong>痛点</strong>，提出了一个反对的声音：<strong>Vue3的升级是一个错误的选择</strong>。</p>\n<p>在一片热议中，甚至<strong>尤大</strong>都出来亲自解释并承认了一些问题。本文列举了一些原文中提到的观点以及<strong>尤大的回复</strong>。希望能给各位读者在实际项目升级时，提供更<strong>实际</strong>更<strong>全面</strong>的参考。</p>\n<h2><a id=\"_6\"></a>前言</h2>\n<p>原作者首先声明了他并没有贬低<strong>Vue3</strong>的意思。他认为<strong>Vue3</strong>是非常非常棒的框架，解决了<strong>Vue2</strong>中很多潜在问题，技术层面改善了开发人员的开发体验，并显著提高了性能。原作者主要的问题，是从Vue3<strong>突破性</strong>的改变以及<strong>周边生态圈</strong>未能及时跟上的角度，重点强调了迁移升级<strong>成本</strong>+<strong>风险</strong>较大。</p>\n<blockquote>\n<p>关于升级成本问题：尤大也承认了<strong>Vue3</strong>升级体验并没有想象中的那么流畅，<strong>Vue4</strong>会吸取经验，做好平稳迭代。这一点本文会在下面详细说明。</p>\n</blockquote>\n<p>接下来，我们针对原文中提到的观点逐一列举解读。</p>\n<blockquote>\n<p>ps: 为了避免语言翻译差异问题，所有<strong>原作者</strong>和<strong>尤大</strong>的观点都是附上英语原文。</p>\n</blockquote>\n<h2><a id=\"apiBreaking_changes_16\"></a>一、破坏性的api变更（Breaking changes）</h2>\n<ul>\n<li><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fv3-migration.vuejs.org%2Fbreaking-changes%2Fevents-api.html\" target=\"_blank\">Events API</a>的弃用让这个问题首当其冲</strong>。（straightforward like the depreciation of the Events API）。Vue实例再也不能作为<strong>事件总线</strong>做事件通信，<code>$</code>on，<code>$</code>off，<code>$</code>once的彻底<strong>移除</strong>意味着之前所有有关代码都必须重新推翻重写，虽然有很好的插件工具让这件事变得没那么复杂，但是仍然会带来不小的迁移成本。</li>\n<li><strong>代码构建问题。</strong> 你会经常遇到用Vue2写法写出来的代码在<strong>构建(build)</strong> 失败或抛出<strong>警告</strong>。因为这些api写法在Vue3中已经被废弃。这问题在已存在的大型项目中的尤为突出（In an existing large-scale application built with Vue 2, you would probably use some of the deprecated or changed APIs）。下图展示了一部分<strong>Breaking changes</strong>，可以看到破坏性的api变更数确实很多：</li>\n</ul>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fa6fa0646044507b581cb93e2f349a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" /></p>\n<h2><a id=\"compositionapi_23\"></a>二、颠覆式的设计模式（composition-api）</h2>\n<p>颠覆式的<strong>composition-api</strong>慢慢向<strong>面向函数</strong>思想转变，导致很多原有习惯于<strong>options-api</strong>的开发者反感Vue正在像react靠拢，没有坚持住Vue特色。它提出了一种新的基于函数的 Vue 组件编写方式，引起了Vue社区大量的争议和分裂，甚至将社区分隔为两种观点阵营针锋相对，最终导致了<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fdev.to%2Fdanielelkington%2Fvue-s-darkest-day-3fgh\" target=\"_blank\">Vue 最黑暗的一天事件</a>。这很令人沮丧。</p>\n<p>(the Request for Comment for the new function-based way of writing Vue components which had an overwhelming amount of responses, both positive and negative.No matter where you stand in this argument splitting the community in half is never a good sign and led to Vue’s Darkest Day and a lot of people getting discouraged over this.)</p>\n', 'Vue2升级到Vue3到底是不是一个正确的选择？', NULL, 0, 0, 17, '2022-07-28 23:51:35', '就在前两天，一篇反对**Vue2**升级到**Vue3**的文章在vue官方社区引起了热议。（原文链接：[Vue 3 was a mistake that we should not repeat](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fjs-dojo%2Fvue-3-was-a-mistake-that-we-should-not-repeat-81cc65484954)）\n\n这篇文章从**实际应用**角度出发，分析了**Vue2**到**Vue3**在真实项目中实操升级的**痛点**，提出了一个反对的声音：**Vue3的升级是一个错误的选择**。\n\n在一片热议中，甚至**尤大**都出来亲自解释并承认了一些问题。本文列举了一些原文中提到的观点以及**尤大的回复**。希望能给各位读者在实际项目升级时，提供更**实际**更**全面**的参考。\n\n## 前言\n\n原作者首先声明了他并没有贬低**Vue3**的意思。他认为**Vue3**是非常非常棒的框架，解决了**Vue2**中很多潜在问题，技术层面改善了开发人员的开发体验，并显著提高了性能。原作者主要的问题，是从Vue3**突破性**的改变以及**周边生态圈**未能及时跟上的角度，重点强调了迁移升级**成本**+**风险**较大。\n\n> 关于升级成本问题：尤大也承认了**Vue3**升级体验并没有想象中的那么流畅，**Vue4**会吸取经验，做好平稳迭代。这一点本文会在下面详细说明。\n\n接下来，我们针对原文中提到的观点逐一列举解读。\n\n> ps: 为了避免语言翻译差异问题，所有**原作者**和**尤大**的观点都是附上英语原文。\n\n## 一、破坏性的api变更（Breaking changes）\n\n- **[Events API](https://link.juejin.cn?target=https%3A%2F%2Fv3-migration.vuejs.org%2Fbreaking-changes%2Fevents-api.html)的弃用让这个问题首当其冲**。（straightforward like the depreciation of the Events API）。Vue实例再也不能作为**事件总线**做事件通信，`$`on，`$`off，`$`once的彻底**移除**意味着之前所有有关代码都必须重新推翻重写，虽然有很好的插件工具让这件事变得没那么复杂，但是仍然会带来不小的迁移成本。\n- **代码构建问题。** 你会经常遇到用Vue2写法写出来的代码在**构建(build)** 失败或抛出**警告**。因为这些api写法在Vue3中已经被废弃。这问题在已存在的大型项目中的尤为突出（In an existing large-scale application built with Vue 2, you would probably use some of the deprecated or changed APIs）。下图展示了一部分**Breaking changes**，可以看到破坏性的api变更数确实很多：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fa6fa0646044507b581cb93e2f349a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n## 二、颠覆式的设计模式（composition-api）\n\n颠覆式的**composition-api**慢慢向**面向函数**思想转变，导致很多原有习惯于**options-api**的开发者反感Vue正在像react靠拢，没有坚持住Vue特色。它提出了一种新的基于函数的 Vue 组件编写方式，引起了Vue社区大量的争议和分裂，甚至将社区分隔为两种观点阵营针锋相对，最终导致了[Vue 最黑暗的一天事件](https://link.juejin.cn?target=https%3A%2F%2Fdev.to%2Fdanielelkington%2Fvue-s-darkest-day-3fgh)。这很令人沮丧。\n\n(the Request for Comment for the new function-based way of writing Vue components which had an overwhelming amount of responses, both positive and negative.No matter where you stand in this argument splitting the community in half is never a good sign and led to Vue’s Darkest Day and a lot of people getting discouraged over this.)\n', '这篇文章从实际应用角度出发，分析了Vue2到Vue3在真实项目中实操升级的痛点，提出了一个反对的声音：Vue3的升级是一个错误的选择。', NULL);
INSERT INTO `article` VALUES (27, 3, '2022-07-25 01:13:36', '<h1><a id=\"_0\"></a>什么是事务</h1>\n<p>事务是数据库操作的最基本单元，是逻辑上的一组操作，要么都成功，要么都失败。是一个不可分割的工作单元。</p>\n<h1><a id=\"_4\"></a>事务的使用</h1>\n<p>事务具有 4 个特性：原子性、一致性、隔离性】持久性，简称为 ACID 特性。</p>\n<ul>\n<li>原子性（Atomicity）：一个事务是一个不可分割的工作单位，一个事务中包括的操作要么都成功要么都失败。</li>\n<li>一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态。比如转账的总金额，不能转着转着总金额少了或者多了。大部分一致性的需求需要程序员写业务代码保证。</li>\n<li>隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相打扰。</li>\n<li>持久性（Durability）：持久性也称为永久性，指一个事务一旦提交，它对数据库中数据的改变就是永久性的，后面的其它操作和故障都不应该对其有任何影响。</li>\n</ul>\n<h1><a id=\"_13\"></a>为什么要用事务</h1>\n<p>举例：银行转账。小明给小红转 100 元。小明需要减少余额 100，小红需要增加余额 100。这是两个操作，需要一起成功。如果在小明转账成功之后发生了异常，就会出现小明 减 100 余额，但是小红并没有加 100 余额。就会造成钱丢失的情况。这是绝对不允许的。伪代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">accountMoney</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">money</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">100</span>;\n    <span class=\"hljs-comment\">//小明 少 100</span>\n    userDao.reduceMoney(money);\n    <span class=\"hljs-comment\">// 其他业务 发生异常</span>\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-comment\">//小红 多 100</span>\n    userDao.addMoney(money);\n}\n</code></div></pre>\n', '拿下 Spring 事务', NULL, 35, 39, 301, '2022-07-29 00:46:10', '# 什么是事务\n\n事务是数据库操作的最基本单元，是逻辑上的一组操作，要么都成功，要么都失败。是一个不可分割的工作单元。\n\n# 事务的使用\n\n事务具有 4 个特性：原子性、一致性、隔离性】持久性，简称为 ACID 特性。\n\n- 原子性（Atomicity）：一个事务是一个不可分割的工作单位，一个事务中包括的操作要么都成功要么都失败。\n- 一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态。比如转账的总金额，不能转着转着总金额少了或者多了。大部分一致性的需求需要程序员写业务代码保证。\n- 隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相打扰。\n- 持久性（Durability）：持久性也称为永久性，指一个事务一旦提交，它对数据库中数据的改变就是永久性的，后面的其它操作和故障都不应该对其有任何影响。\n\n# 为什么要用事务\n\n举例：银行转账。小明给小红转 100 元。小明需要减少余额 100，小红需要增加余额 100。这是两个操作，需要一起成功。如果在小明转账成功之后发生了异常，就会出现小明 减 100 余额，但是小红并没有加 100 余额。就会造成钱丢失的情况。这是绝对不允许的。伪代码如下：\n\n```java\npublic void accountMoney() {\n    int money = 100;\n    //小明 少 100\n    userDao.reduceMoney(money);\n    // 其他业务 发生异常\n    int i = 1/0;\n    //小红 多 100\n    userDao.addMoney(money);\n}\n```\n\n\n\n', '事务是数据库操作的最基本单元，是逻辑上的一组操作，要么都成功，要么都失败。是一个不可分割的工作单元。', NULL);
INSERT INTO `article` VALUES (28, 3, '2022-07-25 01:14:40', '<h3><a id=\"_0\"></a>描述如下</h3>\n<ul>\n<li>同时发多个相同的请求，如果第一个请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回</li>\n<li>如果第一个请求失败了，那么接着发编号为2的请求，如果请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回</li>\n<li>如果第二个请求失败了，那么接着发编号为3的请求，如果请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回</li>\n<li><code>...</code>以此递推，直到遇到最坏的情况需要发送最后一个请求</li>\n</ul>\n<blockquote>\n<p>并发： 一个接口请求还处于pending，短时间内就发送相同的请求</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchData</span> (a)  {\n    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;//127.0.0.1:3000/test&#x27;</span>)\n    <span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-keyword\">await</span> data.<span class=\"hljs-title function_\">json</span>();\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(d);\n    <span class=\"hljs-keyword\">return</span> d;\n}\n\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 编号 1</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 3</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 4</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 4</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 5</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>)\n复制代码\n</code></div></pre>\n<h3><a id=\"cachedAsync_28\"></a>老版本<code>cachedAsync</code></h3>\n<p>我之前使用过<code>vue</code>的缓存函数缓存成功的请求, 实现是这样的。下面的<code>cachedAsync</code>只会缓存成功的请求，如果失败了，直接拉起新的请求。但是如果是上面的并发场景，相同的请求因为无法命中缓存，会出现连续发送三个请求的问题，无法处理这种并发的场景。</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> cachedAsync = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">fn</span>) {\n    <span class=\"hljs-keyword\">const</span> cache = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-literal\">null</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">async</span> str =&gt; {\n        <span class=\"hljs-keyword\">const</span> hit = cache[str];\n        <span class=\"hljs-keyword\">if</span> (hit) {\n            <span class=\"hljs-keyword\">return</span> hit;\n        }\n        <span class=\"hljs-comment\">// 只缓存成功的Promise, 失败直接重新请求</span>\n        <span class=\"hljs-keyword\">return</span> (cache[str] = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fn</span>(str));\n    };\n};\n<span class=\"hljs-keyword\">const</span> fetch2 = <span class=\"hljs-title function_\">cachedAsync</span>(fetchData)\n<span class=\"hljs-title function_\">fetch2</span>(<span class=\"hljs-number\">2</span>);\n<span class=\"hljs-title function_\">fetch2</span>(<span class=\"hljs-number\">2</span>);\n<span class=\"hljs-title function_\">fetch2</span>(<span class=\"hljs-number\">2</span>);\n</code></div></pre>\n', '前端并发10个相同的请求，怎么控制为只发一个请求？', NULL, 0, 0, 5, '2022-07-28 17:46:42', '### 描述如下\n\n- 同时发多个相同的请求，如果第一个请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回\n- 如果第一个请求失败了，那么接着发编号为2的请求，如果请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回\n- 如果第二个请求失败了，那么接着发编号为3的请求，如果请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回\n- `...`以此递推，直到遇到最坏的情况需要发送最后一个请求\n\n> 并发： 一个接口请求还处于pending，短时间内就发送相同的请求\n\n```js\nasync function fetchData (a)  {\n    const data = await fetch(\'//127.0.0.1:3000/test\')\n    const d = await data.json();\n    console.log(d);\n    return d;\n}\n\nfetchData(2) // 编号 1\nfetchData(2) // 2\nfetchData(2) // 3\nfetchData(2) // 4\nfetchData(2) // 4\nfetchData(2) // 5\nfetchData(2)\nfetchData(2)\n复制代码\n```\n\n### 老版本`cachedAsync`\n\n我之前使用过`vue`的缓存函数缓存成功的请求, 实现是这样的。下面的`cachedAsync`只会缓存成功的请求，如果失败了，直接拉起新的请求。但是如果是上面的并发场景，相同的请求因为无法命中缓存，会出现连续发送三个请求的问题，无法处理这种并发的场景。\n\n```js\nconst cachedAsync = function(fn) {\n    const cache = Object.create(null);\n    return async str => {\n        const hit = cache[str];\n        if (hit) {\n            return hit;\n        }\n        // 只缓存成功的Promise, 失败直接重新请求\n        return (cache[str] = await fn(str));\n    };\n};\nconst fetch2 = cachedAsync(fetchData)\nfetch2(2);\nfetch2(2);\nfetch2(2);\n```\n\n', '描述如下\n同时发多个相同的请求，如果第一个请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回', NULL);
INSERT INTO `article` VALUES (110, 1, '2022-07-28 17:03:36', '<h2><a id=\"PaddleHubAI_0\"></a>一、【基于PaddleHub的跳绳AI计数器】智能计数介绍</h2>\n<h3><a id=\"1_1\"></a>1.背景介绍</h3>\n<p>疫情以来，小朋友、大朋友们非必要不外出，都老老实实的画地为牢了。跳绳这类比起跑步等户外活动的优<br />\n势一下子凸显了出来。值此佳节【六一儿童节】到来之际，我给大家弄一个通过手机视频计数的APP方案，<br />\n具体如下，我们小学生也会做啦：</p>\n<h3><a id=\"2_5\"></a>2.实现思路</h3>\n<ul>\n<li>1.用户打开手机APP，将手机固定在场地一侧，适当设置手机角度，根据应用的自动语音提示调整身体与手机距离，直到人体完全位于识别框内，即可开始运动。</li>\n<li>2.通过PaddleHub的human_pose_estimation_resnet50_mpii模型，进行人体关键点检测。</li>\n<li>3.根据检测的数据，计算是否起跳，并计数（此处选择骨盆关键点进行判断，因为跳绳有多种花式，选择其他关键点不一定能记录到），</li>\n<li>4.移植该应用到手机app端</li>\n</ul>\n<p>另外，【六一】活动大家可以积极相应，具体地址：</p>\n<p>精品项目征集方向（一）-青少年主题项目征集 https://aistudio.baidu.com/paddle/forum/topic/show/1729254</p>\n<h2><a id=\"_15\"></a>二、环境准备</h2>\n<p>1.PaddleHub安装<br />\n2.human_pose_estimation_resnet50_mpii模型安装</p>\n<h2><a id=\"_18\"></a>三、人体关键点检测示例</h2>\n<p>1.抓取视频<br />\n2.关键点检测演示</p>\n<h2><a id=\"3_21\"></a>3.寻找转折点</h2>\n<p>四、跳绳检测</p>\n<h2><a id=\"_23\"></a>五、下步打算</h2>\n<p>该项目抛砖引玉，供大家参考。</p>\n<ul>\n<li>加入可视化，实时显示关键点检测以及跳绳计数结果；</li>\n<li>拟采取paddlelite终端部署，或者paddlehub服务器部署调用，结合android客户端、或者电脑加摄像头实现实现方式来验证；</li>\n<li>数据下载软件已上传数据集，大家也可以动手试试。</li>\n</ul>\n', '【基于PaddleHub的跳绳AI计数器】智能计数器', NULL, 1, 0, 16, '2022-07-29 00:26:20', '## 一、【基于PaddleHub的跳绳AI计数器】智能计数介绍\n### 1.背景介绍\n疫情以来，小朋友、大朋友们非必要不外出，都老老实实的画地为牢了。跳绳这类比起跑步等户外活动的优\n势一下子凸显了出来。值此佳节【六一儿童节】到来之际，我给大家弄一个通过手机视频计数的APP方案，\n具体如下，我们小学生也会做啦：\n### 2.实现思路\n- 1.用户打开手机APP，将手机固定在场地一侧，适当设置手机角度，根据应用的自动语音提示调整身体与手机距离，直到人体完全位于识别框内，即可开始运动。\n- 2.通过PaddleHub的human_pose_estimation_resnet50_mpii模型，进行人体关键点检测。\n- 3.根据检测的数据，计算是否起跳，并计数（此处选择骨盆关键点进行判断，因为跳绳有多种花式，选择其他关键点不一定能记录到），\n- 4.移植该应用到手机app端\n\n另外，【六一】活动大家可以积极相应，具体地址：\n\n精品项目征集方向（一）-青少年主题项目征集 https://aistudio.baidu.com/paddle/forum/topic/show/1729254\n\n## 二、环境准备\n1.PaddleHub安装\n2.human_pose_estimation_resnet50_mpii模型安装\n## 三、人体关键点检测示例\n1.抓取视频\n2.关键点检测演示\n## 3.寻找转折点\n四、跳绳检测\n## 五、下步打算\n该项目抛砖引玉，供大家参考。\n\n- 加入可视化，实时显示关键点检测以及跳绳计数结果；\n- 拟采取paddlelite终端部署，或者paddlehub服务器部署调用，结合android客户端、或者电脑加摄像头实现实现方式来验证；\n- 数据下载软件已上传数据集，大家也可以动手试试。\n\n\n', '基于PaddleHub的跳绳AI计数器', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1658999012000.jpg');
INSERT INTO `article` VALUES (111, 1, '2022-07-28 17:22:35', '<h2><a id=\"Kmeans_0\"></a>实现Kmeans算法实现聚类</h2>\n<p>要求： 1、根据算法流程，手动实现Kmeans算法； 2、调用sklearn中聚类算法，对给定数据集进行聚类分<br />\n析； 3、对比上述2中Kmeans算法的聚类效果。</p>\n<h3><a id=\"_3\"></a>读取文件</h3>\n<pre><code class=\"lang-\">def loadFile(path):\n    dataList = []\n    #打开文件：以二进制读模式、utf-8格式的编码方式                                                                                                打开\n    fr = open(path,&quot;r&quot;,encoding=\'UTF-8\')\n    record = fr.read()\n    fr.close\n    #按照行转换为一维表即包含各行作为元素的列表，分隔符有\'\\r\', \'\\r\\n\', \\n\'\n    recordList = record.splitlines()\n    #逐行遍历：行内字段按\'\\t\'分隔符分隔，转换为列表\n    for line in recordList:\n         if line.strip():\n             dataList .append(list(map(float, line.split(\'\\t\'))))\n    #返回转换后的矩阵\n    recordmat = np.mat(dataList )\n    return recordmat\n</code></pre>\n<h3><a id=\"Kmeans_22\"></a>手动实现Kmeans算法</h3>\n<pre><code class=\"lang-\">def kMeans(dataset, k):\n    m = np.shape(dataset)[0]\n    ClustDist = np.mat(np.zeros((m, 2)))\n    cents = randCents(dataset, k)\n    clusterChanged = True\n    # 循环迭代，得到最近的聚类中心\n    while clusterChanged:\n        clusterChanged = False\n        for i in range(m):\n            DistList = [distEclud(dataset[i, :], cents[jk,:]) for jk in range(k)]\n            minDist = min(DistList)\n            minIndex = DistList.index(minDist)\n\n            if ClustDist[i, 0] != minIndex:\n                clusterChanged = True\n            ClustDist[i, :] = minIndex, minDist\n\n        # 更新聚类\n        for cent in range(k):\n            ptsInClust = dataset[np.nonzero(ClustDist[:, 0].A == cent)[0]]\n            # 更新聚类中心cents，axis=0按列求均值\n            cents[cent, :] = np.mean(ptsInClust, axis=0)\n    # 返回聚类中心和聚类分配矩阵\n    return cents, ClustDist\n</code></pre>\n<h3><a id=\"_51\"></a>处理数据</h3>\n<pre><code class=\"lang-\">path_file = &quot;TESTDATA.TXT&quot;\nrecordMat = loadFile(path_file)\nk = 4\n\n\ncents, distMat = kMeans(recordMat, k)\n</code></pre>\n<h3><a id=\"_60\"></a>绘制数据散点图</h3>\n<pre><code class=\"lang-\">plt.subplot(311)\nplt.grid(True)# 生成网格\nfor indx in range(len(distMat)):\n    if distMat[indx, 0] == 0:\n        plt.scatter(recordMat[indx, 0], recordMat[indx, 1], c=\'red\', marker=\'o\')\n    if distMat[indx, 0] == 1:\n        plt.scatter(recordMat[indx, 0], recordMat[indx, 1], c=\'blue\', marker=\'o\')\n    if distMat[indx, 0] == 2:\n        plt.scatter(recordMat[indx, 0], recordMat[indx, 1], c=\'cyan\', marker=\'o\')\n    if distMat[indx, 0] == 3:\n        plt.scatter(recordMat[indx, 0], recordMat[indx, 1], c=\'green\', marker=\'o\')\n\n    #if distMat[indx, 0] == 4:\n        #plt.scatter(recordMat[indx, 0], recordMat[indx, 1], c=\'black\', marker=\'o\')\n</code></pre>\n<h3><a id=\"_78\"></a>绘制聚类中心</h3>\n<pre><code class=\"lang-\">x = [cents[i,0] for i in range(k)]\ny = [cents[i,1] for i in range(k)]\nplt.scatter(x, y, s = 80, c=\'yellow\', marker=\'o\')\nplt.title(\'Kmeans\')\n</code></pre>\n<h3><a id=\"sklearn_86\"></a>调用sklearn中聚类算法</h3>\n<pre><code class=\"lang-\">from sklearn.cluster import KMeans\nX = np.array(recordMat) # 生成初始聚类数据\n#kmeans_model = KMeans(n_clusters=k, init=\'k-means++\')  # 聚类模型\nkmeans_model = KMeans(n_clusters=k, init=\'random\')  # 聚类模型\nkmeans_model.fit(X)  # 训练聚类模型\n</code></pre>\n<h3><a id=\"kMeans_94\"></a>绘制k-Means聚类结果</h3>\n<pre><code class=\"lang-\"> plt.figure()# 创建窗口\nplt.subplot(312)\nplt.axis([np.min(X[:,0])-1, np.max(X[:,0]+1), np.min(X[:,1])-1, np.max(X[:,1])+1])# 坐标轴\nplt.grid(True)# 生成网格\n\ncolors = [\'r\', \'g\', \'b\',\'c\'] # 聚类颜色\nmarkers = [\'o\', \'s\', \'D\', \'+\'] # 聚类标志\nfor i, l in enumerate(kmeans_model.labels_):\n    plt.plot(X[i][0], X[i][1], color=colors[l],marker=markers[l],ls=\'None\')\n    plt.title(\'K = %s,random\' %(k))\n</code></pre>\n', '【人工智能】机器学习之聚类算法Kmeans及其应用', NULL, 1, 0, 5, '2022-07-28 23:57:03', '## 实现Kmeans算法实现聚类\n要求： 1、根据算法流程，手动实现Kmeans算法； 2、调用sklearn中聚类算法，对给定数据集进行聚类分\n析； 3、对比上述2中Kmeans算法的聚类效果。\n### 读取文件\n```\ndef loadFile(path):\n    dataList = []\n    #打开文件：以二进制读模式、utf-8格式的编码方式                                                                                                打开\n    fr = open(path,\"r\",encoding=\'UTF-8\')\n    record = fr.read()\n    fr.close\n    #按照行转换为一维表即包含各行作为元素的列表，分隔符有\'\\r\', \'\\r\\n\', \\n\'\n    recordList = record.splitlines()\n    #逐行遍历：行内字段按\'\\t\'分隔符分隔，转换为列表\n    for line in recordList:\n         if line.strip():\n             dataList .append(list(map(float, line.split(\'\\t\'))))\n    #返回转换后的矩阵\n    recordmat = np.mat(dataList )\n    return recordmat\n```\n\n### 手动实现Kmeans算法\n```\ndef kMeans(dataset, k):\n    m = np.shape(dataset)[0]\n    ClustDist = np.mat(np.zeros((m, 2)))\n    cents = randCents(dataset, k)\n    clusterChanged = True\n    # 循环迭代，得到最近的聚类中心\n    while clusterChanged:\n        clusterChanged = False\n        for i in range(m):\n            DistList = [distEclud(dataset[i, :], cents[jk,:]) for jk in range(k)]\n            minDist = min(DistList)\n            minIndex = DistList.index(minDist)\n\n            if ClustDist[i, 0] != minIndex:\n                clusterChanged = True\n            ClustDist[i, :] = minIndex, minDist\n\n        # 更新聚类\n        for cent in range(k):\n            ptsInClust = dataset[np.nonzero(ClustDist[:, 0].A == cent)[0]]\n            # 更新聚类中心cents，axis=0按列求均值\n            cents[cent, :] = np.mean(ptsInClust, axis=0)\n    # 返回聚类中心和聚类分配矩阵\n    return cents, ClustDist\n```\n\n\n### 处理数据\n```\npath_file = \"TESTDATA.TXT\"\nrecordMat = loadFile(path_file)\nk = 4\n\n\ncents, distMat = kMeans(recordMat, k)\n```\n### 绘制数据散点图\n```\nplt.subplot(311)\nplt.grid(True)# 生成网格\nfor indx in range(len(distMat)):\n    if distMat[indx, 0] == 0:\n        plt.scatter(recordMat[indx, 0], recordMat[indx, 1], c=\'red\', marker=\'o\')\n    if distMat[indx, 0] == 1:\n        plt.scatter(recordMat[indx, 0], recordMat[indx, 1], c=\'blue\', marker=\'o\')\n    if distMat[indx, 0] == 2:\n        plt.scatter(recordMat[indx, 0], recordMat[indx, 1], c=\'cyan\', marker=\'o\')\n    if distMat[indx, 0] == 3:\n        plt.scatter(recordMat[indx, 0], recordMat[indx, 1], c=\'green\', marker=\'o\')\n\n    #if distMat[indx, 0] == 4:\n        #plt.scatter(recordMat[indx, 0], recordMat[indx, 1], c=\'black\', marker=\'o\')\n```\n\n### 绘制聚类中心\n```\nx = [cents[i,0] for i in range(k)]\ny = [cents[i,1] for i in range(k)]\nplt.scatter(x, y, s = 80, c=\'yellow\', marker=\'o\')\nplt.title(\'Kmeans\')\n```\n\n### 调用sklearn中聚类算法\n```\nfrom sklearn.cluster import KMeans\nX = np.array(recordMat) # 生成初始聚类数据\n#kmeans_model = KMeans(n_clusters=k, init=\'k-means++\')  # 聚类模型\nkmeans_model = KMeans(n_clusters=k, init=\'random\')  # 聚类模型\nkmeans_model.fit(X)  # 训练聚类模型\n```\n### 绘制k-Means聚类结果\n\n```\n plt.figure()# 创建窗口\nplt.subplot(312)\nplt.axis([np.min(X[:,0])-1, np.max(X[:,0]+1), np.min(X[:,1])-1, np.max(X[:,1])+1])# 坐标轴\nplt.grid(True)# 生成网格\n\ncolors = [\'r\', \'g\', \'b\',\'c\'] # 聚类颜色\nmarkers = [\'o\', \'s\', \'D\', \'+\'] # 聚类标志\nfor i, l in enumerate(kmeans_model.labels_):\n    plt.plot(X[i][0], X[i][1], color=colors[l],marker=markers[l],ls=\'None\')\n    plt.title(\'K = %s,random\' %(k))\n```\n\n\n\n\n', '本文已参与「新人创作礼」活动， 一起开启掘金创作之路。', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659000036000.jpg');
INSERT INTO `article` VALUES (112, 1, '2022-07-28 17:32:33', '<h2><a id=\"_0\"></a>简介</h2>\n<p>要问2022年什么最火，那莫过于人工智能了。人工智能提了几十年，早在科幻电影中我们就描绘了诸多比人还聪明的机器。什么终结者、超体、攻壳机动队等等都离不开人工智能的影子。在我们的想象中，人工智能是一种人类制造出来的，会自主学习的比人类还聪明的机器。很可惜的是，虽然我们也一直会讨论到底人还是AI才是未来世界的主人，但是AI好像一直都存在于我们的想象中，离人类真实的世界还很远。</p>\n<p>也许AlphaGo的获胜让大家在感到惊奇的同时又有点理所当然，那么由波士顿动力学工程公司设计的机器狗和机器人就让人有点担忧了。看完机器人的街舞表演，你还认为人工智能的时代离我们还远吗？</p>\n<p>虽然我们不能够预测未来人工智能能够发展到哪一步，但是现在停下来了解下人工智能的底层原理会不会对我们在未来的生存提供一丝丝帮助呢？好了，现在我们进入人工智能的基础机器学习的世界。</p>\n<p>顾名思义，机器学习就是使用机器来进行学习，机器指的是计算机，学习指的是学习历史事件的规律，从而能够在特定的环境中进行反应或者行为预测。机器学习是包括计算机科学，工程技术学，统计学概率论等多个学科的综合体。大数据是机器学习的基础。机器学习可以从海量的数据中使用一定的算法，从而将无序的数据转换成为有用的信息。</p>\n<h2><a id=\"_10\"></a>机器学习的应用场景</h2>\n<p>上面我讲到了，机器学习就是使用机器根据历史数据来学习一定的规律，从而对未来发生的事情进行一个预测或者判断。所以机器学习需要学习大量的历史数据，这就是学习一词的来历。</p>\n<p>为什么会有机器学习呢？我们先来考虑一个科幻场景。如果要你来制作一个机器人你会怎么做？</p>\n<p>大家可能会首先想到，制作一个机器人的框架，这个机器人有手有脚，可以活动，还可以卖萌。高级点的，可能想到这个机器人能不能像变形金刚那样能够变形。</p>\n<p>很好，上面大家已经实现了一个机器人玩具。但是这个机器人没啥实际意义，只能当做玩具。能不能智能一点呢？</p>\n<p>我们尝试着给它套上一套软件，用软件来控制他的前进后退。这就是遥控机器人了。这个机器人已经比较智能了，但是还完全控制在遥控器的手上。</p>\n<p>我们更进一步，这个机器人能不能自己根据外界的环境来做相应的行动？先来一个简单点的场景，我们可能把历史数据存到机器人的电脑里面，如果遇到场景和历史场景一样的情况，就做出相应的行动。这样就实现了一个基本的人工智能。</p>\n<p>再进一步，如果遇到的场景和历史场景有一些差别，机器人的电脑能不能识别这些场景，进行采取正确的行动？</p>\n<p>最后，如果遇到额场景和历史场景完全不同，机器人又如何去响应呢？</p>\n<p>作为一个程序员，我们是怎么解决这个问题呢？最简单的可能就是通过各种if else的决策规则来进行数据的处理。如果决策场景比较多，还可以设计一个规则体系模型。但是这些人为的制造规则存在着一些问题：第一个问题是决策规则使用的范围比较窄，如果任务有变化，那么需要重写整个逻辑。第二个问题是要想正确的制定决策，需要对整个过程有深入的理解。还有一个问题是，人类决策的方式和计算机决策的方式是完全不同的，比如在图像识别领域，计算机能够识别的只是像素，这个和人类的感知方式是完全不一样的，从而导致人类制定的规则可能无法在计算机中应用。</p>\n<p>所以我们需要一种机器学习的方法，来帮助人们进行场景识别和预测。</p>\n<p>目前机器学习的应用非常广泛，比如垃圾邮件判断、医学影像识别、信用卡交易欺诈识别、证券市场分析、计算机视觉等方向。</p>\n<h2><a id=\"_33\"></a>机器学习的主要任务和算法</h2>\n<p>机器学习之所以能够替代人类进行信息决策，是因为底层使用的优秀算法。机器学习的主要任务有四种，分别是：分类、回归、聚类和密度估计。根据是否有确定的目标值，可以将机器学习的算法分为监督学习和非监督学习两种。</p>\n<h2><a id=\"_36\"></a>监督学习</h2>\n<p>监督学习就是说学习的历史数据中有输入也有输出。在决策过程中，通过提供给算法历史的输入和输出数据，算法会找到一种方法，根据给定的输入给出预测的结果。算法的高明之处在于，即使给出的输入值在历史数据中并没有出现过，算法也可以根据内在的联系去预测预期的结果。</p>\n<p>这种算法需要通过给定的历史结果来对算法进行校正，就好像有人在监督一样，所以叫做监督学习。</p>\n<p>监督学习比较好理解，它的常见应用就是分类和回归。</p>\n<p>相应的因为有对应的结果，所以监督学习算法的评估就比较容易进行。只需要跟实际的结果进行比较就可以了。</p>\n<h2><a id=\"_44\"></a>非监督学习</h2>\n<p>非监督学习就是说给定的历史数据只有输入，没有输出。算法尝试在这些数据中寻找内在的规律。因为并没有输入，所以对于这种算法的评估就比较困难。<br />\n常见的非监督学习的应用包括聚类、密度估计等。</p>\n<p>之前看过一个非监督学习的比较有趣的应用，就是分析金庸武侠小说中的人物，对这些人物进行分类等操作。因为你并不知道非监督学习到底会输出什么样的结果，所以往往会带给人不一样的惊喜。</p>\n<h2><a id=\"_49\"></a>分类</h2>\n<p>分类是监督学习的一种，目标是预测类别信息。给定的历史数据是特征信息和其对应的分类信息。通过算法训练，可以将未来的输入划分到给定的类别中。根据分类的类别个数不同，分类又可以分为二分类和多分类。</p>\n<p>主要的分类算法包括：回归分析、决策树、人工神经网络、贝叶斯网络、支持向量机等。</p>\n<h2><a id=\"_53\"></a>回归</h2>\n<p>分类算法预测的是离散值，而回归算法预测的就是连续值。回归算法也是监督学习的一种。比如根据股票的历史走势来预测股票未来的价格。<br />\n区分分类和回归的简单方法就是看这个输出是否具有连续性。</p>\n<p>常用的回归算法有：线性回归、非线性回归、逻辑回归、岭回归和主成分回归等。</p>\n<h2><a id=\"_58\"></a>聚类</h2>\n<p>聚类和分类有些类似，但是聚类是无监督学习方法，和分类不同的是，在聚类算法中，并没有给出最后可分类的具体数据，这一切都是由算法本身来控制的。聚类是根据数据自身的距离或者相似度来将其划分为不同的组别。划分的原则是组内的距离最小，而组外的距离最大。</p>\n<p>常见的聚类方法包括：划分法、层次分析法、基于密度的方法、基于网格的方法和基于模型的方法等。</p>\n<h2><a id=\"_62\"></a>密度估计</h2>\n<p>密度估计也是无监督学习的一种，但是它通过样本分布的紧密程度，来估计与分组的相似性。</p>\n<h1><a id=\"_65\"></a>机器学习的应用步骤</h1>\n<p>选好了算法只是机器学习中一个步骤，接下来我们来看一下一个完整的机器学习的过程是怎么样的。<br />\n一般来说机器学习都可以分为以下6个步骤。</p>\n<h2><a id=\"1_69\"></a>1,收集数据</h2>\n<p>机器学习的基础就是海量的数据。在收集数据阶段，我们借助大数据和爬虫之类的各种手段来收集所有可能有用的数据，机器学习将会学习这些数据中的规律，然后进行预测。</p>\n<h2><a id=\"2_73\"></a>2,准备数据</h2>\n<p>在获得可用的数据之后，我们需要将其转换为计算机能够识别的数据，并规定好他们的数据格式，方便输入到计算机中。</p>\n<h2><a id=\"3_77\"></a>3,分析数据</h2>\n<p>数据输入到计算机之后，需要对输入的数据进行分析。如果数据非常多的话，还需要对现有数据进行取样，找出一个和目标相关的样本数据子集。选取的标准主要是相关性，可靠性和有效性。通过对数据的选择，一方面可以减少数据的处理量提高数据的处理速度，另一方面可以消除噪声数据对目标结果的干扰。</p>\n<p>选择完数据之后，接着就是对数据进行探索，审核和必要的加工处理。包括异常值分析，缺失值分析，周期性分析和相关性分析等。这些处理的目的是保证数据的质量，进而保证机器学习的准确性。</p>\n<p>分析完之后就是进行数据的预处理，包括填补数据、清楚重复数据、数据标准化、变量转换、主成分分析、数据规约等清洗、转换和重塑的操作。</p>\n<h2><a id=\"4_85\"></a>4,训练算法</h2>\n<p>有了样本数据之后，就可以开始真正的机器学习了，通过将第三步的数据格式化输入到选择的算法模型中，经过不断的训练，可以得到一个训练好的模型。</p>\n<h2><a id=\"5_89\"></a>5,测试算法</h2>\n<p>使用步骤4得到的模型，选择特定的数据来测试该模型的准确性。通过比较预测值和真实值的差异，可以选择重复3-4步骤来修正模型。最终得到一个在误差范围之类的模型。</p>\n<h2><a id=\"6_93\"></a>6,使用算法</h2>\n<p>应用该模型，将该模型转换为应用程序，并执行实际任务，在实际任务中进一步对该模型进行检测。</p>\n<h2><a id=\"_96\"></a>机器学习的数学基础</h2>\n<p>听起来机器学习是一件很高大上的事情，那么我们在使用机器学习的过程中需要掌握什么数学知识吗？</p>\n<p>通常来说机器学习的各种算法中可能会用到微积分、线性代数、概率论等知识。我们如果想要对这些算法有一个深刻的认识，肯定是要掌握相关的数学知识。</p>\n<p>但是作为机器学习的应用者来说，我们并不需要深入研究这些算法的底层，只需要知道这些算法的原理，并能够应用即可。</p>\n<h2><a id=\"_102\"></a>机器学习的工具</h2>\n<p>机器学习的利器就是Python了。经过这么多年的发展，Python提供了众多的关于机器学习相关的库，非常的强大。我们可以在python中使用非常简单的代码即可以实现复杂的功能。比如数据分析的库：NumPy和Pandas，科学计算的库：SciPy等等。</p>\n<p>好了，有了这些基础知识之后，我们就可以开始探索机器学习的世界了。</p>\n', '2022最新机器学习引导手册', NULL, 0, 0, 3, '2022-07-28 21:07:03', '## 简介\n要问2022年什么最火，那莫过于人工智能了。人工智能提了几十年，早在科幻电影中我们就描绘了诸多比人还聪明的机器。什么终结者、超体、攻壳机动队等等都离不开人工智能的影子。在我们的想象中，人工智能是一种人类制造出来的，会自主学习的比人类还聪明的机器。很可惜的是，虽然我们也一直会讨论到底人还是AI才是未来世界的主人，但是AI好像一直都存在于我们的想象中，离人类真实的世界还很远。\n\n也许AlphaGo的获胜让大家在感到惊奇的同时又有点理所当然，那么由波士顿动力学工程公司设计的机器狗和机器人就让人有点担忧了。看完机器人的街舞表演，你还认为人工智能的时代离我们还远吗？\n\n虽然我们不能够预测未来人工智能能够发展到哪一步，但是现在停下来了解下人工智能的底层原理会不会对我们在未来的生存提供一丝丝帮助呢？好了，现在我们进入人工智能的基础机器学习的世界。\n\n顾名思义，机器学习就是使用机器来进行学习，机器指的是计算机，学习指的是学习历史事件的规律，从而能够在特定的环境中进行反应或者行为预测。机器学习是包括计算机科学，工程技术学，统计学概率论等多个学科的综合体。大数据是机器学习的基础。机器学习可以从海量的数据中使用一定的算法，从而将无序的数据转换成为有用的信息。\n\n\n## 机器学习的应用场景\n上面我讲到了，机器学习就是使用机器根据历史数据来学习一定的规律，从而对未来发生的事情进行一个预测或者判断。所以机器学习需要学习大量的历史数据，这就是学习一词的来历。\n\n为什么会有机器学习呢？我们先来考虑一个科幻场景。如果要你来制作一个机器人你会怎么做？\n\n大家可能会首先想到，制作一个机器人的框架，这个机器人有手有脚，可以活动，还可以卖萌。高级点的，可能想到这个机器人能不能像变形金刚那样能够变形。\n\n很好，上面大家已经实现了一个机器人玩具。但是这个机器人没啥实际意义，只能当做玩具。能不能智能一点呢？\n\n我们尝试着给它套上一套软件，用软件来控制他的前进后退。这就是遥控机器人了。这个机器人已经比较智能了，但是还完全控制在遥控器的手上。\n\n我们更进一步，这个机器人能不能自己根据外界的环境来做相应的行动？先来一个简单点的场景，我们可能把历史数据存到机器人的电脑里面，如果遇到场景和历史场景一样的情况，就做出相应的行动。这样就实现了一个基本的人工智能。\n\n再进一步，如果遇到的场景和历史场景有一些差别，机器人的电脑能不能识别这些场景，进行采取正确的行动？\n\n最后，如果遇到额场景和历史场景完全不同，机器人又如何去响应呢？\n\n作为一个程序员，我们是怎么解决这个问题呢？最简单的可能就是通过各种if else的决策规则来进行数据的处理。如果决策场景比较多，还可以设计一个规则体系模型。但是这些人为的制造规则存在着一些问题：第一个问题是决策规则使用的范围比较窄，如果任务有变化，那么需要重写整个逻辑。第二个问题是要想正确的制定决策，需要对整个过程有深入的理解。还有一个问题是，人类决策的方式和计算机决策的方式是完全不同的，比如在图像识别领域，计算机能够识别的只是像素，这个和人类的感知方式是完全不一样的，从而导致人类制定的规则可能无法在计算机中应用。\n\n所以我们需要一种机器学习的方法，来帮助人们进行场景识别和预测。\n\n目前机器学习的应用非常广泛，比如垃圾邮件判断、医学影像识别、信用卡交易欺诈识别、证券市场分析、计算机视觉等方向。\n\n## 机器学习的主要任务和算法\n机器学习之所以能够替代人类进行信息决策，是因为底层使用的优秀算法。机器学习的主要任务有四种，分别是：分类、回归、聚类和密度估计。根据是否有确定的目标值，可以将机器学习的算法分为监督学习和非监督学习两种。\n\n## 监督学习\n监督学习就是说学习的历史数据中有输入也有输出。在决策过程中，通过提供给算法历史的输入和输出数据，算法会找到一种方法，根据给定的输入给出预测的结果。算法的高明之处在于，即使给出的输入值在历史数据中并没有出现过，算法也可以根据内在的联系去预测预期的结果。\n\n这种算法需要通过给定的历史结果来对算法进行校正，就好像有人在监督一样，所以叫做监督学习。\n\n监督学习比较好理解，它的常见应用就是分类和回归。\n\n相应的因为有对应的结果，所以监督学习算法的评估就比较容易进行。只需要跟实际的结果进行比较就可以了。\n## 非监督学习\n非监督学习就是说给定的历史数据只有输入，没有输出。算法尝试在这些数据中寻找内在的规律。因为并没有输入，所以对于这种算法的评估就比较困难。\n常见的非监督学习的应用包括聚类、密度估计等。\n\n之前看过一个非监督学习的比较有趣的应用，就是分析金庸武侠小说中的人物，对这些人物进行分类等操作。因为你并不知道非监督学习到底会输出什么样的结果，所以往往会带给人不一样的惊喜。\n## 分类\n分类是监督学习的一种，目标是预测类别信息。给定的历史数据是特征信息和其对应的分类信息。通过算法训练，可以将未来的输入划分到给定的类别中。根据分类的类别个数不同，分类又可以分为二分类和多分类。\n\n主要的分类算法包括：回归分析、决策树、人工神经网络、贝叶斯网络、支持向量机等。\n## 回归\n分类算法预测的是离散值，而回归算法预测的就是连续值。回归算法也是监督学习的一种。比如根据股票的历史走势来预测股票未来的价格。\n区分分类和回归的简单方法就是看这个输出是否具有连续性。\n\n常用的回归算法有：线性回归、非线性回归、逻辑回归、岭回归和主成分回归等。\n## 聚类\n聚类和分类有些类似，但是聚类是无监督学习方法，和分类不同的是，在聚类算法中，并没有给出最后可分类的具体数据，这一切都是由算法本身来控制的。聚类是根据数据自身的距离或者相似度来将其划分为不同的组别。划分的原则是组内的距离最小，而组外的距离最大。\n\n常见的聚类方法包括：划分法、层次分析法、基于密度的方法、基于网格的方法和基于模型的方法等。\n## 密度估计\n密度估计也是无监督学习的一种，但是它通过样本分布的紧密程度，来估计与分组的相似性。\n\n# 机器学习的应用步骤\n选好了算法只是机器学习中一个步骤，接下来我们来看一下一个完整的机器学习的过程是怎么样的。\n一般来说机器学习都可以分为以下6个步骤。\n\n## 1,收集数据\n\n机器学习的基础就是海量的数据。在收集数据阶段，我们借助大数据和爬虫之类的各种手段来收集所有可能有用的数据，机器学习将会学习这些数据中的规律，然后进行预测。\n\n## 2,准备数据\n\n在获得可用的数据之后，我们需要将其转换为计算机能够识别的数据，并规定好他们的数据格式，方便输入到计算机中。\n\n## 3,分析数据\n\n数据输入到计算机之后，需要对输入的数据进行分析。如果数据非常多的话，还需要对现有数据进行取样，找出一个和目标相关的样本数据子集。选取的标准主要是相关性，可靠性和有效性。通过对数据的选择，一方面可以减少数据的处理量提高数据的处理速度，另一方面可以消除噪声数据对目标结果的干扰。\n\n选择完数据之后，接着就是对数据进行探索，审核和必要的加工处理。包括异常值分析，缺失值分析，周期性分析和相关性分析等。这些处理的目的是保证数据的质量，进而保证机器学习的准确性。\n\n分析完之后就是进行数据的预处理，包括填补数据、清楚重复数据、数据标准化、变量转换、主成分分析、数据规约等清洗、转换和重塑的操作。\n\n## 4,训练算法\n\n有了样本数据之后，就可以开始真正的机器学习了，通过将第三步的数据格式化输入到选择的算法模型中，经过不断的训练，可以得到一个训练好的模型。\n\n## 5,测试算法\n\n使用步骤4得到的模型，选择特定的数据来测试该模型的准确性。通过比较预测值和真实值的差异，可以选择重复3-4步骤来修正模型。最终得到一个在误差范围之类的模型。\n\n## 6,使用算法\n\n应用该模型，将该模型转换为应用程序，并执行实际任务，在实际任务中进一步对该模型进行检测。\n## 机器学习的数学基础\n听起来机器学习是一件很高大上的事情，那么我们在使用机器学习的过程中需要掌握什么数学知识吗？\n\n通常来说机器学习的各种算法中可能会用到微积分、线性代数、概率论等知识。我们如果想要对这些算法有一个深刻的认识，肯定是要掌握相关的数学知识。\n\n但是作为机器学习的应用者来说，我们并不需要深入研究这些算法的底层，只需要知道这些算法的原理，并能够应用即可。\n## 机器学习的工具\n机器学习的利器就是Python了。经过这么多年的发展，Python提供了众多的关于机器学习相关的库，非常的强大。我们可以在python中使用非常简单的代码即可以实现复杂的功能。比如数据分析的库：NumPy和Pandas，科学计算的库：SciPy等等。\n\n好了，有了这些基础知识之后，我们就可以开始探索机器学习的世界了。\n\n', '机器学习应该如何学', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659000751000.jpg');
INSERT INTO `article` VALUES (113, 2, '2022-07-28 17:38:36', '<p>Vue 是目前用于创建用户界面的最佳 JavaScript 框架之一，本文推荐 Vue 项目开发用得上的 6 个第三方库，<br />\n这些库基本可以覆盖项目大部份需求，有效的提高项目开发效率。如果不希望过多的使用第三方库，这<br />\n些库则可以作为学习，从中吸取精华开发自己的依赖库。</p>\n<h3><a id=\"1_vueeasytable_4\"></a>1. vue-easytable</h3>\n<p>vue-easytable 提供了一个功能齐全且高度可定制的表格组件/数据集合，支持许多功能，如虚拟滚动、列固定、标题固定、标题分组、过滤器、排序、单元格省略号、行扩展、行复选框等等。单元测试覆盖率超过 85%，在 Github 上超过 2800 颗星。<br />\nGIT地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHappy-Coding-Clans%2Fvue-easytable</p>\n<h3><a id=\"2_vueecharts_7\"></a>2. vue-echarts</h3>\n<p>如果项目正在创建一个数据驱动的应用程序，那么它很可能有一个图表。在这种情况下，vue-echarts 对项目来说是一个很好的资源。该库提供了许多漂亮且可自定义的图表，例如条形图、饼图、极坐标图、散点图等等，这个库在 Github 上有超过 7300 颗星。<br />\nGIT地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fvue-echarts</p>\n<h3><a id=\"3_vuenotification_10\"></a>3. vue-notification</h3>\n<p>vue-notification 用于显示通知消息，在应用程序中，通知消息可以有效的提醒用户，是个不错的用户体验。这个库将帮助创建一个漂亮的通知。它提供了许多功能，例如动画、自定义位置、自定义样式等等。这个库在 Github 上有超过 2300 颗星。<br />\nGIT地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fvue-echarts</p>\n<h3><a id=\"4_vuewait_13\"></a>4. vue-wait</h3>\n<p>vue-wait 可以控制页面上的各种加载状态而不会发生任何冲突。它的核心原理是管理具有多个加载状态的数组。集成加载器组件开始监听其注册的加载器并立即进入加载状态。这个库在 Github 上有超过 1900 颗星。<br />\n官方地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fvue-echarts</p>\n<h3><a id=\"5_vuejsmodal_16\"></a>5. vue-js-modal</h3>\n<p>vue-js-moda 是一个易于使用、高度可定制的 Vue 模态库。该库支持静态和动态两种模式，静态是通过模板显式定义的，动态是根据传递给“显示模式”函数的配置生成的。这个库在 Github 上有超过 4100 颗星。<br />\nGIT地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fvue-echarts</p>\n<h3><a id=\"6_vueagile_19\"></a>6. vue-agile</h3>\n<p>这是一个受 Slick 启发的 Vue 轮播库。这个库提供了一个功能强大、响应迅速且触摸友好的轮播。它还支持 SSR ，它不依赖于 jQuery。这个库在 Github 上有超过 1400 颗星。<br />\nGIT地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fvue-echarts</p>\n<h3><a id=\"_22\"></a>总结</h3>\n<p>上面介绍的 6 个依赖库，基本可以覆盖项目大部份需求实现。当然现在也有很多一整套UI的VUE库，如 Ant Design of Vue，合理利用第三方库可以有效的提高开发效率。</p>\n', '推荐 6 个实用的 Vue 组件库', NULL, 1, 0, 7, '2022-07-28 23:57:10', 'Vue 是目前用于创建用户界面的最佳 JavaScript 框架之一，本文推荐 Vue 项目开发用得上的 6 个第三方库，\n这些库基本可以覆盖项目大部份需求，有效的提高项目开发效率。如果不希望过多的使用第三方库，这\n些库则可以作为学习，从中吸取精华开发自己的依赖库。\n\n### 1. vue-easytable\nvue-easytable 提供了一个功能齐全且高度可定制的表格组件/数据集合，支持许多功能，如虚拟滚动、列固定、标题固定、标题分组、过滤器、排序、单元格省略号、行扩展、行复选框等等。单元测试覆盖率超过 85%，在 Github 上超过 2800 颗星。\nGIT地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHappy-Coding-Clans%2Fvue-easytable\n### 2. vue-echarts\n如果项目正在创建一个数据驱动的应用程序，那么它很可能有一个图表。在这种情况下，vue-echarts 对项目来说是一个很好的资源。该库提供了许多漂亮且可自定义的图表，例如条形图、饼图、极坐标图、散点图等等，这个库在 Github 上有超过 7300 颗星。\nGIT地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fvue-echarts\n### 3. vue-notification\nvue-notification 用于显示通知消息，在应用程序中，通知消息可以有效的提醒用户，是个不错的用户体验。这个库将帮助创建一个漂亮的通知。它提供了许多功能，例如动画、自定义位置、自定义样式等等。这个库在 Github 上有超过 2300 颗星。\nGIT地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fvue-echarts\n### 4. vue-wait\nvue-wait 可以控制页面上的各种加载状态而不会发生任何冲突。它的核心原理是管理具有多个加载状态的数组。集成加载器组件开始监听其注册的加载器并立即进入加载状态。这个库在 Github 上有超过 1900 颗星。\n官方地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fvue-echarts\n### 5. vue-js-modal\nvue-js-moda 是一个易于使用、高度可定制的 Vue 模态库。该库支持静态和动态两种模式，静态是通过模板显式定义的，动态是根据传递给“显示模式”函数的配置生成的。这个库在 Github 上有超过 4100 颗星。\nGIT地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fvue-echarts\n### 6. vue-agile\n这是一个受 Slick 启发的 Vue 轮播库。这个库提供了一个功能强大、响应迅速且触摸友好的轮播。它还支持 SSR ，它不依赖于 jQuery。这个库在 Github 上有超过 1400 颗星。\nGIT地址：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fvue-echarts\n### 总结\n上面介绍的 6 个依赖库，基本可以覆盖项目大部份需求实现。当然现在也有很多一整套UI的VUE库，如 Ant Design of Vue，合理利用第三方库可以有效的提高开发效率。\n', '实用的 Vue 组件库推荐', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659001114000.jpg');
INSERT INTO `article` VALUES (114, 2, '2022-07-28 17:44:38', '<p><strong>你是不是还在手写按钮、文本字体等简单样式？这些工具就可以帮你解决以上种种难题，从此下班<br />\n你将快人一步，赶快用起来吧！</strong></p>\n<h3><a id=\"01_CSS_Button_Generator_3\"></a>01 CSS Button Generator</h3>\n<p>地址：cssbuttongenerator.com/<br />\n推荐：★★★★★<br />\n简介：CSS Button Generator是一个免费的在线工具，可让您创建跨浏览器的 HTML 和CSS 按钮样式，您不必学习任何复杂的CSS规则。只需单击并滑动即可制作CSS 3按钮。很多漂亮的按钮样本。</p>\n<h3><a id=\"02__8\"></a>02 花式边界半径</h3>\n<p>地址：9elements.github.io/fancy-borde…</p>\n<p>推荐：★★★★★</p>\n<p>简介：通过拖拽的形式生成需要的border-radius！</p>\n<h3><a id=\"03__15\"></a>03 平滑阴影</h3>\n<p>地址：shadows.brumm.af/</p>\n<p>推荐：★★★★★</p>\n<p>简介：可以生成多个分层阴影，提供非常酷的效果，你也可以自定义颜色。</p>\n<h3><a id=\"04__22\"></a>04 阴影生成器</h3>\n<p>地址：neumorphism.io/</p>\n<p>推荐：★★★★★</p>\n<p>简介：此网站通过 选择颜色：或大小：半径：距离：强度：模糊：形状：复制边框半径：50px;背景，生成非常nice的阴影，让你的界面更加的美观自然。</p>\n<h3><a id=\"05_css_29\"></a>05 css在线工具</h3>\n<p>地址： tool.lu/css/<br />\n推荐：★★★★<br />\n简介：美化：格式化代码，使之容易阅读。净化：将代码单行化，并去除注释。整理：按照一定的顺序，重新排列css的属性。优化：将css的长属性值优化为简写的形式。压缩：将代码最小化，加快加载速度！</p>\n<h3><a id=\"06_cssgradient_34\"></a>06 cssgradient</h3>\n<p>地址：cssgradient.io/</p>\n<p>推荐：★★★★</p>\n<p>简介：CSS Gradient 是一个快乐的小网站和免费工具，可让您为网站创建渐变背景。</p>\n<h3><a id=\"07_css_41\"></a>07 css网格生成器</h3>\n<p>地址：cssgrid-generator.netlify.app/</p>\n<p>推荐：★★★★★</p>\n<p>简介：您可以设置行和列的数字还有单位，我将为您生成一个 CSS Grid 网格布局！在方框中拖动来创建 div 放置在网格内。</p>\n', '有了这些前端css工具，我下班都更早了！', NULL, 1, 0, 24, '2022-07-28 23:57:47', '**你是不是还在手写按钮、文本字体等简单样式？这些工具就可以帮你解决以上种种难题，从此下班\n你将快人一步，赶快用起来吧！**\n\n### 01 CSS Button Generator\n地址：cssbuttongenerator.com/\n推荐：★★★★★\n简介：CSS Button Generator是一个免费的在线工具，可让您创建跨浏览器的 HTML 和CSS 按钮样式，您不必学习任何复杂的CSS规则。只需单击并滑动即可制作CSS 3按钮。很多漂亮的按钮样本。\n\n### 02 花式边界半径\n地址：9elements.github.io/fancy-borde…\n\n推荐：★★★★★\n\n简介：通过拖拽的形式生成需要的border-radius！\n\n### 03 平滑阴影\n地址：shadows.brumm.af/\n\n推荐：★★★★★\n\n简介：可以生成多个分层阴影，提供非常酷的效果，你也可以自定义颜色。\n\n### 04 阴影生成器\n地址：neumorphism.io/\n\n推荐：★★★★★\n\n简介：此网站通过 选择颜色：或大小：半径：距离：强度：模糊：形状：复制边框半径：50px;背景，生成非常nice的阴影，让你的界面更加的美观自然。\n\n### 05 css在线工具\n地址： tool.lu/css/\n推荐：★★★★\n简介：美化：格式化代码，使之容易阅读。净化：将代码单行化，并去除注释。整理：按照一定的顺序，重新排列css的属性。优化：将css的长属性值优化为简写的形式。压缩：将代码最小化，加快加载速度！\n\n### 06 cssgradient\n地址：cssgradient.io/\n\n推荐：★★★★\n\n简介：CSS Gradient 是一个快乐的小网站和免费工具，可让您为网站创建渐变背景。\n\n### 07 css网格生成器\n地址：cssgrid-generator.netlify.app/\n\n推荐：★★★★★\n\n简介：您可以设置行和列的数字还有单位，我将为您生成一个 CSS Grid 网格布局！在方框中拖动来创建 div 放置在网格内。\n\n', 'CSS工具推荐', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659001476000.jpg');
INSERT INTO `article` VALUES (115, 3, '2022-07-28 17:53:42', '<h2><a id=\"_0\"></a>一、原理区别</h2>\n<p>一般我们在浏览器输入一个网址访问网站都是GET请求;再FORM表单中，可以通过设置Method指定提交方式为GET或者POST提交方式，默认为GET提交方式。</p>\n<p>HTTP定义了与服务器交互的不同方法，其中最基本的四种：GET，POST，PUT，DELETE，HEAD，其中GET和HEAD被称为安全方法，因为使用GET和HEAD的HTTP请求不会产生什么动作。不会产生动作意味着GET和HEAD的HTTP请求不会在服务器上产生任何结果。但是安全方法并不是什么动作都不产生，这里的安全方法仅仅指不会修改信息。</p>\n<p>根据HTTP规范，POST可能会修改服务器上的资源的请求。比如知乎编写文章，用户提交一篇文章或者一个读者提交评论是通过POST请求来实现的，因为再提交文章或者评论提交后资源（即某个页面）不同了，或者说资源被修改了，这些便是“不安全方法”。</p>\n<h2><a id=\"_7\"></a>二、使用时最直观的区别</h2>\n<p>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</p>\n<h2><a id=\"getpost_10\"></a>三、为什么get比post更快</h2>\n<h3><a id=\"1post_11\"></a>1.post请求包含更多的请求头</h3>\n<p>因为post需要在请求的body部分包含数据，所以会多了几个数据描述部分的首部字段（如：content-type）,这其实是微乎其微的。</p>\n<h3><a id=\"2postpost_13\"></a>2.最重要的一条，post在真正接收数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据post请求的过程：</h3>\n<p>（1）浏览器请求tcp连接（第一次握手）</p>\n<p>（2）服务器答应进行tcp连接（第二次握手）</p>\n<p>（3）浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</p>\n<p>（4）服务器返回100 Continue响应</p>\n<p>（5）浏览器发送数据</p>\n<p>（6）服务器返回200 OK响应</p>\n<p>get请求的过程：</p>\n<p>（1）浏览器请求tcp连接（第一次握手）</p>\n<p>（2）服务器答应进行tcp连接（第二次握手）</p>\n<p>（3）浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</p>\n<p>（4）服务器返回200 OK响应</p>\n<p>也就是说，目测get的总耗是post的2/3左右，这个口说无凭，网上已经有网友进行过测试。</p>\n<h3><a id=\"3getpost_38\"></a>3.get会将数据缓存起来，而post不会</h3>\n<p>可以做个简短的测试，使用ajax采用get方式请求静态数据（比如html页面，图片）的时候，如果两次传输的数据相同，第二次以后消耗的时间将会在10ms以内（chrome测试），而post每次消耗的时间都差不多。经测试，chrome和firefox下如果检测到get请求的是静态资源，则会缓存，如果是数据，则不会缓存，但是IE什么都会缓存起来，当然，应该没有人用post去获取静态数据吧，反正我是没见过。</p>\n<h2><a id=\"getpost_41\"></a>四、面试是一般怎么回答get和post的区别</h2>\n<p>（1）post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）</p>\n<p>（2）post发送的数据更大（get有url长度限制）</p>\n<p>（3）post能发送更多的数据类型（get只能发送ASCII字符）</p>\n<p>（4）post比get慢</p>\n<p>（5）post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据</p>\n<h2><a id=\"getpost_52\"></a>五、测试get和post请求的工具</h2>\n<p>get和post请求一般使用的是接口测试工具，接口测试工具我个人一般使用的是:apipost和jmeter。</p>\n<p>apipost是一款国产的接口测试工具和接口文档生成工具，能够满足我们日常工作当中对于接口测试和接口文档生成的工作需求。接口文档还可以支持多种格式的生成，有在线版、markdown、word版等多种格式的接口文档。</p>\n<p>jmeter可以进行接口测试和性能测试，但是对于做单纯的接口测试jmeter操作起来没有apipost使用起来方便。jmeter重点在于压力测试，稳定性测试和负载测试。针对于接口和程序的稳定性设计的一块以软件性能为主接口测试为辅的接口测试工具。</p>\n', 'http请求中get和post方法的区别', NULL, 0, 0, 4, '2022-07-28 18:24:14', '## 一、原理区别\n一般我们在浏览器输入一个网址访问网站都是GET请求;再FORM表单中，可以通过设置Method指定提交方式为GET或者POST提交方式，默认为GET提交方式。\n\nHTTP定义了与服务器交互的不同方法，其中最基本的四种：GET，POST，PUT，DELETE，HEAD，其中GET和HEAD被称为安全方法，因为使用GET和HEAD的HTTP请求不会产生什么动作。不会产生动作意味着GET和HEAD的HTTP请求不会在服务器上产生任何结果。但是安全方法并不是什么动作都不产生，这里的安全方法仅仅指不会修改信息。\n\n根据HTTP规范，POST可能会修改服务器上的资源的请求。比如知乎编写文章，用户提交一篇文章或者一个读者提交评论是通过POST请求来实现的，因为再提交文章或者评论提交后资源（即某个页面）不同了，或者说资源被修改了，这些便是“不安全方法”。\n\n## 二、使用时最直观的区别\n最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。\n\n## 三、为什么get比post更快\n### 1.post请求包含更多的请求头\n因为post需要在请求的body部分包含数据，所以会多了几个数据描述部分的首部字段（如：content-type）,这其实是微乎其微的。\n### 2.最重要的一条，post在真正接收数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据post请求的过程：\n（1）浏览器请求tcp连接（第一次握手）\n\n（2）服务器答应进行tcp连接（第二次握手）\n\n（3）浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）\n\n（4）服务器返回100 Continue响应\n\n（5）浏览器发送数据\n\n（6）服务器返回200 OK响应\n\nget请求的过程：\n\n（1）浏览器请求tcp连接（第一次握手）\n\n（2）服务器答应进行tcp连接（第二次握手）\n\n（3）浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）\n\n（4）服务器返回200 OK响应\n\n也就是说，目测get的总耗是post的2/3左右，这个口说无凭，网上已经有网友进行过测试。\n\n### 3.get会将数据缓存起来，而post不会\n\n可以做个简短的测试，使用ajax采用get方式请求静态数据（比如html页面，图片）的时候，如果两次传输的数据相同，第二次以后消耗的时间将会在10ms以内（chrome测试），而post每次消耗的时间都差不多。经测试，chrome和firefox下如果检测到get请求的是静态资源，则会缓存，如果是数据，则不会缓存，但是IE什么都会缓存起来，当然，应该没有人用post去获取静态数据吧，反正我是没见过。\n## 四、面试是一般怎么回答get和post的区别\n（1）post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）\n\n（2）post发送的数据更大（get有url长度限制）\n\n（3）post能发送更多的数据类型（get只能发送ASCII字符）\n\n（4）post比get慢\n\n（5）post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据\n\n## 五、测试get和post请求的工具\n\nget和post请求一般使用的是接口测试工具，接口测试工具我个人一般使用的是:apipost和jmeter。\n\napipost是一款国产的接口测试工具和接口文档生成工具，能够满足我们日常工作当中对于接口测试和接口文档生成的工作需求。接口文档还可以支持多种格式的生成，有在线版、markdown、word版等多种格式的接口文档。\n\njmeter可以进行接口测试和性能测试，但是对于做单纯的接口测试jmeter操作起来没有apipost使用起来方便。jmeter重点在于压力测试，稳定性测试和负载测试。针对于接口和程序的稳定性设计的一块以软件性能为主接口测试为辅的接口测试工具。\n\n\n', 'http请求中get和post方法的区别', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659002020000.jpg');
INSERT INTO `article` VALUES (116, 3, '2022-07-28 17:58:42', '<h3><a id=\"1D2admin_0\"></a>1.D2admin</h3>\n<p>开源地址：github.com/d2-projects…</p>\n<p>文档地址：d2.pub/zh/doc/d2-a…</p>\n<p>效果预览：d2.pub/d2-admin/pr…</p>\n<p>开源协议：MIT</p>\n<h3><a id=\"2vueelementadmin_9\"></a>2.vue-element-admin</h3>\n<p>开源地址：github.com/PanJiaChen/…<br />\n文档地址：panjiachen.github.io/vue-element…<br />\n效果预览：panjiachen.github.io/vue-element…<br />\n开源协议：MIT</p>\n<h3><a id=\"3JEECGBOOT_15\"></a>3.JEECG-BOOT</h3>\n<p>开源地址：github.com/zhangdaisco…</p>\n<p>文档地址：panjiachen.github.io/vue-element…</p>\n<p>效果预览：boot.jeecg.com/</p>\n<p>开源协议：Apache-2.0 License</p>\n<h3><a id=\"4GINVUEADMIN_24\"></a>4.GIN-VUE-ADMIN</h3>\n<p>开源地址：github.com/flipped-aur…<br />\n文档地址：www.gin-vue-admin.com/<br />\n效果预览：demo.gin-vue-admin.com/#/layout/da…<br />\n开源协议：Apache-2.0 License</p>\n<h3><a id=\"5vueadminbeautiful_30\"></a>5.vue-admin-beautiful</h3>\n<p>开源地址：github.com/chuzhixin/v…</p>\n<p>文档地址：www.gin-vue-admin.com/</p>\n<p>效果预览：beautiful.panm.cn/</p>\n<p>开源协议：MPL-2.0 License</p>\n<h3><a id=\"6Dcatadmin_39\"></a>6.Dcat-admin</h3>\n<p>开源地址：github.com/jqhph/dcat-…</p>\n<p>文档地址：www.dcatadmin.com/</p>\n<p>效果预览：http://103.39.211.179:8080/admin</p>\n<p>开源协议：MIT License</p>\n<h3><a id=\"7RuoYi_48\"></a>7.RuoYi</h3>\n<p>开源地址：gitee.com/y_project/R…</p>\n<p>文档地址：doc.ruoyi.vip/</p>\n<p>效果预览：vue.ruoyi.vip/index</p>\n<p>开源协议：MIT License</p>\n<h3><a id=\"8renrenfastvue_57\"></a>8.renren-fast-vue</h3>\n<p>开源地址：gitee.com/renrenio/re…</p>\n<p>文档地址：www.renren.io/guide</p>\n<p>效果预览：demo.open.renren.io/renren-fast…</p>\n<p>开源协议：MIT License</p>\n<h3><a id=\"9antdesignpro_66\"></a>9.ant-design-pro</h3>\n<p>开源地址：github.com/ant-design/…</p>\n<p>文档地址：pro.ant.design/index-cn/</p>\n<p>效果预览：pro.ant.design/</p>\n<p>开源协议：MIT License</p>\n<h3><a id=\"10iviewadmin_75\"></a>10.iview-admin</h3>\n<p>开源地址：github.com/iview/iview…</p>\n<p>文档地址：lison16.github.io/iview-admin…</p>\n<p>效果预览：admin.iviewui.com/home</p>\n<p>开源协议：MIT License</p>\n<h3><a id=\"11materialdashboard_84\"></a>11.material-dashboard</h3>\n<p>开源地址：github.com/creativetim…<br />\n文档地址：demos.creative-tim.com/material-da…<br />\n效果预览：demos.creative-tim.com/material-da…<br />\n开源协议：MIT License</p>\n<h3><a id=\"12EAdmin_90\"></a>12.EAdmin</h3>\n<p>开源地址：github.com/suruibuas/e…</p>\n<p>文档地址：doc.eadmin.com.cn/</p>\n<p>效果预览：www.eadmin.com.cn/</p>\n<p>开源协议：无</p>\n', '12 个适合做外包项目的开源后台管理系统', NULL, 0, 0, 9, '2022-07-29 00:52:06', '### 1.D2admin\n开源地址：github.com/d2-projects…\n\n文档地址：d2.pub/zh/doc/d2-a…\n\n效果预览：d2.pub/d2-admin/pr…\n\n开源协议：MIT\n\n### 2.vue-element-admin\n开源地址：github.com/PanJiaChen/…\n文档地址：panjiachen.github.io/vue-element…\n效果预览：panjiachen.github.io/vue-element…\n开源协议：MIT\n\n### 3.JEECG-BOOT\n开源地址：github.com/zhangdaisco…\n\n文档地址：panjiachen.github.io/vue-element…\n\n效果预览：boot.jeecg.com/\n\n开源协议：Apache-2.0 License\n\n### 4.GIN-VUE-ADMIN\n开源地址：github.com/flipped-aur…\n文档地址：www.gin-vue-admin.com/\n效果预览：demo.gin-vue-admin.com/#/layout/da…\n开源协议：Apache-2.0 License\n\n### 5.vue-admin-beautiful\n开源地址：github.com/chuzhixin/v…\n\n文档地址：www.gin-vue-admin.com/\n\n效果预览：beautiful.panm.cn/\n\n开源协议：MPL-2.0 License\n\n### 6.Dcat-admin\n开源地址：github.com/jqhph/dcat-…\n\n文档地址：www.dcatadmin.com/\n\n效果预览：http://103.39.211.179:8080/admin\n\n开源协议：MIT License\n\n### 7.RuoYi\n开源地址：gitee.com/y_project/R…\n\n文档地址：doc.ruoyi.vip/\n\n效果预览：vue.ruoyi.vip/index\n\n开源协议：MIT License\n\n### 8.renren-fast-vue\n开源地址：gitee.com/renrenio/re…\n\n文档地址：www.renren.io/guide\n\n效果预览：demo.open.renren.io/renren-fast…\n\n开源协议：MIT License\n\n### 9.ant-design-pro\n开源地址：github.com/ant-design/…\n\n文档地址：pro.ant.design/index-cn/\n\n效果预览：pro.ant.design/\n\n开源协议：MIT License\n\n### 10.iview-admin\n开源地址：github.com/iview/iview…\n\n文档地址：lison16.github.io/iview-admin…\n\n效果预览：admin.iviewui.com/home\n\n开源协议：MIT License\n\n### 11.material-dashboard\n开源地址：github.com/creativetim…\n文档地址：demos.creative-tim.com/material-da…\n效果预览：demos.creative-tim.com/material-da…\n开源协议：MIT License\n\n### 12.EAdmin\n开源地址：github.com/suruibuas/e…\n\n文档地址：doc.eadmin.com.cn/\n\n效果预览：www.eadmin.com.cn/\n\n开源协议：无\n\n', '适合做外包项目的开源后台管理系统', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659002321000.jpg');
INSERT INTO `article` VALUES (117, 4, '2022-07-28 18:09:14', '<h2><a id=\"_0\"></a>一、索引</h2>\n<p>在之前，我对索引有以下的认知：</p>\n<ul>\n<li>索引可以加快数据库的检索速度</li>\n<li>表经常进行INSERT/UPDATE/DELETE操作就不要建立索引了，换言之：索引会降低插入、删除、修改等维护任务的速度。</li>\n<li>索引需要占物理和数据空间。</li>\n<li>了解过索引的最左匹配原则</li>\n<li>知道索引的分类：聚集索引和非聚集索引</li>\n<li>Mysql支持Hash索引和B+树索引两种</li>\n</ul>\n<h3><a id=\"GG_10\"></a>看起来好像啥都知道，但面试让你说的时候可能就GG了：</h3>\n<ul>\n<li>使用索引为什么可以加快数据库的检索速度啊？</li>\n<li>为什么说索引会降低插入、删除、修改等维护任务的速度。</li>\n<li>索引的最左匹配原则指的是什么？</li>\n<li>Hash索引和B+树索引有什么区别？主流的使用哪一个比较多？InnoDB存储都支持吗？</li>\n<li>聚集索引和非聚集索引有什么区别？</li>\n<li>…</li>\n</ul>\n', '数据库神器之索引', NULL, 2, 0, 6, '2022-07-28 23:18:40', '## 一、索引\n在之前，我对索引有以下的认知：\n\n- 索引可以加快数据库的检索速度\n- 表经常进行INSERT/UPDATE/DELETE操作就不要建立索引了，换言之：索引会降低插入、删除、修改等维护任务的速度。\n- 索引需要占物理和数据空间。\n- 了解过索引的最左匹配原则\n- 知道索引的分类：聚集索引和非聚集索引\n- Mysql支持Hash索引和B+树索引两种\n\n### 看起来好像啥都知道，但面试让你说的时候可能就GG了：\n\n- 使用索引为什么可以加快数据库的检索速度啊？\n- 为什么说索引会降低插入、删除、修改等维护任务的速度。\n- 索引的最左匹配原则指的是什么？\n- Hash索引和B+树索引有什么区别？主流的使用哪一个比较多？InnoDB存储都支持吗？\n- 聚集索引和非聚集索引有什么区别？\n- ........\n\n', '数据库神器之索引', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659002950000.jpg');
INSERT INTO `article` VALUES (118, 4, '2022-07-28 18:22:20', '<h2><a id=\"1_0\"></a>1，什么是存储过程？有哪些优缺点？</h2>\n<h3><a id=\"_1\"></a>存储过程的优点：</h3>\n<ul>\n<li>能够将代码封装起来</li>\n<li>保存在数据库之中</li>\n<li>让编程语言进行调用</li>\n<li>存储过程是一个预编译的代码块，执行效率比较高</li>\n<li>一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率</li>\n</ul>\n<h3><a id=\"_9\"></a>存储过程的缺点：</h3>\n<ul>\n<li>每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）</li>\n<li>业务逻辑放在数据库上，难以迭代</li>\n</ul>\n<h2><a id=\"2_14\"></a>2，三个范式是什么</h2>\n<p>首先要明确的是：满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式</p>\n<h3><a id=\"_17\"></a>第一范式：字段是最小的的单元不可再分</h3>\n<p>学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的</p>\n<h3><a id=\"_22\"></a>第二范式：满足第一范式,表中的字段必须完全依赖于全部主键而非部分主键。</h3>\n<p>其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的<br />\n学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。</p>\n<h3><a id=\"_28\"></a>第三范式：满足第二范式，非主键外的所有字段必须互不依赖</h3>\n<p>就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖<br />\n比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。</p>\n', '数据库面试题(开发者必看)', NULL, 1, 0, 11, '2022-07-29 00:04:49', '## 1，什么是存储过程？有哪些优缺点？\n### 存储过程的优点：\n\n- 能够将代码封装起来\n- 保存在数据库之中\n- 让编程语言进行调用\n- 存储过程是一个预编译的代码块，执行效率比较高\n- 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率\n\n### 存储过程的缺点：\n\n- 每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）\n- 业务逻辑放在数据库上，难以迭代\n\n## 2，三个范式是什么\n\n首先要明确的是：满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式\n### 第一范式：字段是最小的的单元不可再分\n\n学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的\n\n\n### 第二范式：满足第一范式,表中的字段必须完全依赖于全部主键而非部分主键。\n\n其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的\n学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。\n\n\n### 第三范式：满足第二范式，非主键外的所有字段必须互不依赖\n\n就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖\n比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。\n', '数据库面试题', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659003732000.jpg');
INSERT INTO `article` VALUES (127, 1, '2022-07-28 22:12:26', '<h2><a id=\"_0\"></a>前置</h2>\n<p>1、HTTP概述<br />\nHTTP中文名为：超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。</p>\n<p>2、TCP6个标志位<br />\nSYN(synchronous建立联机) 、ACK(acknowledgement 确认)、 PSH(push传送)、FIN(finish结束)、RST(reset重置)、URG(urgent紧急)</p>\n<h2><a id=\"_7\"></a>三次握手</h2>\n<h3><a id=\"_8\"></a>我们以（鲁班）给（鲁班大师）打电话为例</h3>\n<p>鲁班</p>\n<div class=\"hljs-right\">\n<p>喂，你好 ? SYN（seq = x）?</p>\n</div>\n<p>鲁班大师</p>\n<div class=\"hljs-right\">\n<p>ACK（ack = x + 1）SYN（seq = y）喂，你好，能听到吗 ?</p>\n</div>\n<p>鲁班</p>\n<div class=\"hljs-right\">\n<p>ACK(ack = y + 1) 我能听到!</p>\n</div>\n<p>鲁班大师</p>\n<h3><a id=\"_32\"></a>解析</h3>\n<p>此处的（鲁班）就是我们的客户端、（鲁班大师）就是服务端</p>\n<h4><a id=\"_35\"></a>第一次握手</h4>\n<p>鲁班拿出手机（此处代表客户端机器），拨通了鲁班大师的电话（此处代表服务端）在三声嘟嘟嘟，说了句喂，你好？并丢出了一个SYN包，包里有个Synchronize Sequence Numbers（也就是seq=x），它的值为x，然后满意的把手机设为SYN_SENT状态，等待鲁班大师回答。</p>\n<h4><a id=\"_37\"></a>第二次握手</h4>\n<p>这时鲁班大师电话响了，接通电话，就迎面砸来了鲁班丢来的包，然后打开包一看里面有个x，根据他多年的经验，立马就生成了一个ACK确认包,包里有个Acknowledge number（也就是ack = x + 1），这时他想了想，不能被白砸，于是也生成了一个SYN包，并放入（seq = y）,随之将两个包一并丢给鲁班，然后开心的将手机设为SYN_RECV状态，等待鲁班回应。</p>\n<h4><a id=\"_39\"></a>第三次握手</h4>\n<p>鲁班等了会，接到了鲁班大师丢来的两个包，打开一看，ACK（ack = x + 1）SYN(seq = y),聪明的鲁班心领神会，仿照鲁班大师，也丢出了ACK（ack = y + 1）的包，发送完毕之后，客户端和服务器进入ESTABLISHED，这时TCP连接成功，三次握手完毕。</p>\n<h3><a id=\"_42\"></a>这时小伙伴就提出了问题，干嘛非要三次，两次不香吗？</h3>\n<p>以我们的想法，两次确实可以，但是出于安全考虑，第三次握手是非常重要的。</p>\n<p>第一次握手，服务器可以知道客户端是可以发送消息的</p>\n<p>第二次握手，客户端知道，服务器是可以连接的</p>\n<p>第三次握手，服务器可以很明确的知道，我发给客户端的东西，客户端是可以接收到的</p>\n<p>倘若没有第三次握手，第二次握手完成后，服务端就直接发送东西给客户端，而不巧的是，这时候客户端却断开了连接，服务端却不知道，依然给客户端发送东西，那客户端肯定是无法接收到服务端发来的东西的，由此可见，三次握手必不可少</p>\n', 'HTTP三次握手', NULL, 0, 0, 2, '2022-07-28 22:17:15', '## 前置\n1、HTTP概述\nHTTP中文名为：超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。\n\n2、TCP6个标志位\nSYN(synchronous建立联机) 、ACK(acknowledgement 确认)、 PSH(push传送)、FIN(finish结束)、RST(reset重置)、URG(urgent紧急)\n\n## 三次握手\n### 我们以（鲁班）给（鲁班大师）打电话为例\n鲁班                        \n::: hljs-right\n\n喂，你好 ? SYN（seq = x）?\n\n:::\n\n鲁班大师\n::: hljs-right\n\nACK（ack = x + 1）SYN（seq = y）喂，你好，能听到吗 ?\n\n:::\n\n鲁班\n::: hljs-right\n\nACK(ack = y + 1) 我能听到!\n\n:::\n\n鲁班大师\n\n### 解析\n此处的（鲁班）就是我们的客户端、（鲁班大师）就是服务端\n\n#### 第一次握手\n鲁班拿出手机（此处代表客户端机器），拨通了鲁班大师的电话（此处代表服务端）在三声嘟嘟嘟，说了句喂，你好？并丢出了一个SYN包，包里有个Synchronize Sequence Numbers（也就是seq=x），它的值为x，然后满意的把手机设为SYN_SENT状态，等待鲁班大师回答。\n#### 第二次握手\n这时鲁班大师电话响了，接通电话，就迎面砸来了鲁班丢来的包，然后打开包一看里面有个x，根据他多年的经验，立马就生成了一个ACK确认包,包里有个Acknowledge number（也就是ack = x + 1），这时他想了想，不能被白砸，于是也生成了一个SYN包，并放入（seq = y）,随之将两个包一并丢给鲁班，然后开心的将手机设为SYN_RECV状态，等待鲁班回应。\n#### 第三次握手\n鲁班等了会，接到了鲁班大师丢来的两个包，打开一看，ACK（ack = x + 1）SYN(seq = y),聪明的鲁班心领神会，仿照鲁班大师，也丢出了ACK（ack = y + 1）的包，发送完毕之后，客户端和服务器进入ESTABLISHED，这时TCP连接成功，三次握手完毕。\n\n### 这时小伙伴就提出了问题，干嘛非要三次，两次不香吗？\n以我们的想法，两次确实可以，但是出于安全考虑，第三次握手是非常重要的。\n\n第一次握手，服务器可以知道客户端是可以发送消息的\n\n第二次握手，客户端知道，服务器是可以连接的\n\n第三次握手，服务器可以很明确的知道，我发给客户端的东西，客户端是可以接收到的\n\n倘若没有第三次握手，第二次握手完成后，服务端就直接发送东西给客户端，而不巧的是，这时候客户端却断开了连接，服务端却不知道，依然给客户端发送东西，那客户端肯定是无法接收到服务端发来的东西的，由此可见，三次握手必不可少\n', 'HTTP三次握手详细解读，不容错过', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659017544000.jpg');
INSERT INTO `article` VALUES (128, 1, '2022-07-28 22:19:12', '<h2><a id=\"_0\"></a>一、什么是懒加载？什么预加载？</h2>\n<p>懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。<br />\n有的网站图片很多，而如果一上来就加载所有的图片，会导致网页加载很慢</p>\n<p>图片懒加载：等图片正式进入到可视区中时，才加载对应的图片，否则不请求图片</p>\n<p>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</p>\n<h2><a id=\"_8\"></a>二、图片懒加载的基本实现</h2>\n<p>图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载。</p>\n<p><strong>注意：data-xxx 中的xxx可以自定义，这里我们使用data-src来定义。</strong></p>\n<p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p>\n<pre><code class=\"lang-language\">&lt;div class=&quot;container&quot;&gt;\n     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;\n     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;\n     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;\n     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;\n     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;\n     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;\n&lt;/div&gt;\n&lt;script&gt;\nvar imgs = document.querySelectorAll(\'img\');\nfunction lozyLoad(){\n		var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n		var winHeight= window.innerHeight;\n		for(var i=0;i &lt; imgs.length;i++){\n			if(imgs[i].offsetTop &lt; scrollTop + winHeight ){\n				imgs[i].src = imgs[i].getAttribute(\'data-src\');\n			}\n		}\n	}\n  window.onscroll = lozyLoad();\n&lt;/script&gt;\n</code></pre>\n<h2><a id=\"Intersection_Observer_39\"></a>三、Intersection Observer实现图片懒加载</h2>\n<p>Intersection Observer是HTML5新增的API，可以用来实现图片懒加载。MDN中对Intersection Observer的解释</p>\n<p>IntersectionObserver接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。</p>\n<p>当一个IntersectionObserver对象被创建时，其被配置为监听根中一段给定比例的可见区域。一旦IntersectionObserver被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值；然而，你可以在同一个观察者对象中配置监听多个目标元素。</p>\n<p>这里封装一个组件并且自定义一个v-lazy属性，然后替换到src上，实现懒加载。</p>\n<pre><code class=\"lang-\">import { useIntersectionObserver } from &quot;@vueuse/core&quot;;\nimport defaultImg from \'@/assets/images/200.png\'\nimport { App } from \'vue\';\n\nexport default {\n    install(app: App) {\n        // 全局指令\n        app.directive(\'lazy\', {\n            // mounted 是 v3 中自定义指令的生命周期，他会被自动调用\n            // 它表示的含义和组件的mounted是一样的\n            // el是 dom 元素， binding\n            mounted(el, binding) {\n                el.src = defaultImg\n                console.log(\'lazy\', el, binding.value);\n\n                //实时鉴定el是否可见， 如果可见 给它的src设置binding.value\n                const { stop } = useIntersectionObserver(el, ([{ isIntersecting }]) =&gt; {\n                    if (isIntersecting) {\n                        el.src = binding.value\n\n                        stop()\n                        el.onerror = function () {\n                            el.src = defaultImg\n                        }\n                    }\n                })\n\n            }\n        })\n    }\n}\n</code></pre>\n<pre><code class=\"lang-\"> &lt;img  v-lazy=&quot;item.picture&quot;   alt=&quot;&quot;/&gt;\n</code></pre>\n<h2><a id=\"__86\"></a>四. 延迟加载视频</h2>\n<p>图片和视频这类静态资源资源占比都最大。与图片一样，视频同样可以延迟加载，来达到优化性能的目的。正常情况下加载视频，使用的是 video 标签，那么对于一些需要由用户自己播放的视频，最好指定video标签的preload属性为none，这样浏览器就不会预加载任何视频数据。为了占用空间，使用poster属性为video占位。如下：</p>\n<pre><code class=\"lang-\">&lt;video controls preload=&quot;none&quot; poster=&quot;replace.jpg&quot;&gt;\n  &lt;source src=&quot;main.webm&quot; type=&quot;video/webm&quot;&gt;\n  &lt;source src=&quot;main.mp4&quot; type=&quot;video/mp4&quot;&gt;\n&lt;/video&gt;\n</code></pre>\n<h2><a id=\"__95\"></a>五. 使用第三方延迟加载库</h2>\n<p>除了上面介绍的一些延迟加载方法之外，还可以借助一些已经封装好的第三方库，下面是一些成熟的第三方库：</p>\n<p>lozad.js 是超轻量级且只使用 Intersection Observer 的库， 因此它的性能极佳，但如果要在旧版本浏览器上使用，则需要配置polyfill。</p>\n<p>lazysizes 是功能全面的延迟加载库，其使用的模式与本文所示的代码示例非常相似，会自动与  元素上的lazyload 类绑定，然后在data-src 和/或 data-srcset 属性中指定图像网址，该库还可以通过许多插件进行扩展，执行延迟各种资源等操作。</p>\n<p>如果使用React，可以使用 react-lazyload来进行图片懒加载操作，这个库是React图片懒加载的主流解决方案。</p>\n<p><strong>参考文章链接：https://blog.csdn.net/qq_42033567/article/details/113757978</strong></p>\n', '【前端性能优化】前端懒加载', NULL, 2, 0, 5, '2022-07-28 23:31:47', '## 一、什么是懒加载？什么预加载？\n懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。\n有的网站图片很多，而如果一上来就加载所有的图片，会导致网页加载很慢\n\n图片懒加载：等图片正式进入到可视区中时，才加载对应的图片，否则不请求图片\n\n预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。\n\n## 二、图片懒加载的基本实现\n图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载。\n\n**注意：data-xxx 中的xxx可以自定义，这里我们使用data-src来定义。**\n\n懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。\n\n```language\n<div class=\"container\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n</div>\n<script>\nvar imgs = document.querySelectorAll(\'img\');\nfunction lozyLoad(){\n		var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n		var winHeight= window.innerHeight;\n		for(var i=0;i < imgs.length;i++){\n			if(imgs[i].offsetTop < scrollTop + winHeight ){\n				imgs[i].src = imgs[i].getAttribute(\'data-src\');\n			}\n		}\n	}\n  window.onscroll = lozyLoad();\n</script>\n```\n\n## 三、Intersection Observer实现图片懒加载\nIntersection Observer是HTML5新增的API，可以用来实现图片懒加载。MDN中对Intersection Observer的解释\n\nIntersectionObserver接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。\n\n\n当一个IntersectionObserver对象被创建时，其被配置为监听根中一段给定比例的可见区域。一旦IntersectionObserver被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值；然而，你可以在同一个观察者对象中配置监听多个目标元素。\n\n这里封装一个组件并且自定义一个v-lazy属性，然后替换到src上，实现懒加载。\n\n```\nimport { useIntersectionObserver } from \"@vueuse/core\";\nimport defaultImg from \'@/assets/images/200.png\'\nimport { App } from \'vue\';\n\nexport default {\n    install(app: App) {\n        // 全局指令\n        app.directive(\'lazy\', {\n            // mounted 是 v3 中自定义指令的生命周期，他会被自动调用\n            // 它表示的含义和组件的mounted是一样的\n            // el是 dom 元素， binding\n            mounted(el, binding) {\n                el.src = defaultImg\n                console.log(\'lazy\', el, binding.value);\n\n                //实时鉴定el是否可见， 如果可见 给它的src设置binding.value\n                const { stop } = useIntersectionObserver(el, ([{ isIntersecting }]) => {\n                    if (isIntersecting) {\n                        el.src = binding.value\n\n                        stop()\n                        el.onerror = function () {\n                            el.src = defaultImg\n                        }\n                    }\n                })\n\n            }\n        })\n    }\n}\n```\n\n```\n <img  v-lazy=\"item.picture\"   alt=\"\"/>\n```\n## 四. 延迟加载视频\n图片和视频这类静态资源资源占比都最大。与图片一样，视频同样可以延迟加载，来达到优化性能的目的。正常情况下加载视频，使用的是 video 标签，那么对于一些需要由用户自己播放的视频，最好指定video标签的preload属性为none，这样浏览器就不会预加载任何视频数据。为了占用空间，使用poster属性为video占位。如下：\n\n```\n<video controls preload=\"none\" poster=\"replace.jpg\">\n  <source src=\"main.webm\" type=\"video/webm\">\n  <source src=\"main.mp4\" type=\"video/mp4\">\n</video>\n```\n## 五. 使用第三方延迟加载库\n除了上面介绍的一些延迟加载方法之外，还可以借助一些已经封装好的第三方库，下面是一些成熟的第三方库：\n\nlozad.js 是超轻量级且只使用 Intersection Observer 的库， 因此它的性能极佳，但如果要在旧版本浏览器上使用，则需要配置polyfill。\n\nlazysizes 是功能全面的延迟加载库，其使用的模式与本文所示的代码示例非常相似，会自动与  元素上的lazyload 类绑定，然后在data-src 和/或 data-srcset 属性中指定图像网址，该库还可以通过许多插件进行扩展，执行延迟各种资源等操作。\n\n如果使用React，可以使用 react-lazyload来进行图片懒加载操作，这个库是React图片懒加载的主流解决方案。\n\n**参考文章链接：https://blog.csdn.net/qq_42033567/article/details/113757978**\n\n\n\n\n\n\n\n', '想要优化你的前端的性能吗？还不快来学习学习', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659017908000.jpg');
INSERT INTO `article` VALUES (129, 1, '2022-07-28 22:27:32', '<h2><a id=\"_0\"></a>这是一篇关于居中对齐方式的总结</h2>\n<p>开篇之前，先问一下大家都知道几种居中的实现方式？</p>\n<p>面试时答出来两三个就不错了，就怕面试官还让你继续说。今天就来总结一下这些居中的方式</p>\n<ol>\n<li>使用flex布局设置居中。</li>\n<li>使用flex 时也能通过给子项设置margin: auto实现居中。</li>\n<li>使用绝对定位的方式实现水平垂直居中。</li>\n<li>使用grid设置居中。</li>\n<li>使用grid时还能通过给子项设置margin: auto实现居中。</li>\n<li>使用tabel-cell实现垂直居中。</li>\n<li>还有一种不常用的方法实现垂直居中。</li>\n<li>最后还有一种奇葩的方法。容器设置position: relative。孩子设置 top、left、bottom、right都设置为0</li>\n</ol>\n<h2><a id=\"1flex_14\"></a>1.flex布局设置居中</h2>\n<p>常见的一种方式就是使用flex布局设置居中。<br />\n利用弹性布局(flex)，实现水平居中，其中justify-content 用于设置弹性盒子元素在主轴（横轴）方向上的对齐方式<br />\n给容器设置：</p>\n<p>display: flex;写在父元素上这就是定义了一个伸缩容器</p>\n<p>justify-content 主轴对齐方式，默认是横轴</p>\n<p>align-items 纵轴对齐方式，默认是纵轴</p>\n<p>优点： 简单、方便、快速，三行代码搞定。</p>\n<h2><a id=\"2flex_31\"></a>2.flex-给子项设置</h2>\n<p>第一种方式是给父盒子设置属性，这一种是给子盒子设置margin: auto实现居中。</p>\n<p>给容器设置 display: flex; 子项设置 margin: auto;</p>\n<h2><a id=\"3_36\"></a>3.绝对定位</h2>\n<p>使用绝对定位的方式实现水平垂直居中。容器设置position: relative。子元素设置 position: absolute; left: 50%; top: 50%; transfrom: translate(-50%, -50%);</p>\n<p>优点就是不用关心子元素的长和宽，但是这种方法兼容性依赖translate2d的兼容性</p>\n<h2><a id=\"4tabelcell_41\"></a>4.tabel-cell实现垂直居中</h2>\n<p>css新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中<br />\n而且tabel单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了</p>\n<p>使用tabel-cell实现垂直居中,容器设置 display: table-cell;;</p>\n<p>vertical-align: middle属性设置元素的垂直对齐方式</p>\n<p>子元素如果是块级元素，直接使用左右margin:auto实现水平居中。如果是行内元素，给容器设置text-align: center</p>\n<p>利用 text-align: center 可以实现在块级元素内部的内联元素水平居中。此方法对内联元素inline, 内联块inline-block, 内联表inline-table, inline-flex元素水平居中都有效。</p>\n<h2><a id=\"5grid_58\"></a>5.grid设置居中</h2>\n<p>使用grid设置居中。给容器设置 display: grid; align-items: center; justify-content: center;</p>\n<p>通过给容器设置属性，达到居中效果,但是这种方式兼容性较差，不推荐。</p>\n<h2><a id=\"6grid_63\"></a>6.grid给子项设置</h2>\n<p>使用grid时还能通过给子项设置margin: auto;实现居中。给容器设置 display: grid; 子项设置 margin: auto;</p>\n<p>某些浏览器会不支持grid布局方式，兼容性较差，不推荐。</p>\n<h2><a id=\"7_68\"></a>7.给容器加给伪元素</h2>\n<p>这是一种不常用的方法实现垂直居中。给容器加给伪元素，设置line-height等于容器的高度。给孩子设置display: inline-block;</p>\n<p>此种方式适合给文本设置水平垂直居中</p>\n<h2><a id=\"8_73\"></a>8.还有一种奇葩的方法</h2>\n<p>这个奇葩方式和第三种使用绝对定位相似，只不过需要给子元素设置 position: absolute; 设置固定宽度和高度;top、left、bottom、right都设置为0; margin设置为auto；也能实现垂直水平居中。</p>\n', 'css居中实现方式', NULL, 0, 0, 2, '2022-07-28 22:29:28', '## 这是一篇关于居中对齐方式的总结\n开篇之前，先问一下大家都知道几种居中的实现方式？\n\n面试时答出来两三个就不错了，就怕面试官还让你继续说。今天就来总结一下这些居中的方式\n\n1. 使用flex布局设置居中。\n2. 使用flex 时也能通过给子项设置margin: auto实现居中。\n3. 使用绝对定位的方式实现水平垂直居中。\n4. 使用grid设置居中。\n5. 使用grid时还能通过给子项设置margin: auto实现居中。\n6. 使用tabel-cell实现垂直居中。\n7. 还有一种不常用的方法实现垂直居中。\n8. 最后还有一种奇葩的方法。容器设置position: relative。孩子设置 top、left、bottom、right都设置为0\n\n## 1.flex布局设置居中\n常见的一种方式就是使用flex布局设置居中。\n利用弹性布局(flex)，实现水平居中，其中justify-content 用于设置弹性盒子元素在主轴（横轴）方向上的对齐方式\n给容器设置：\n\n\ndisplay: flex;写在父元素上这就是定义了一个伸缩容器\n\n\njustify-content 主轴对齐方式，默认是横轴\n\n\nalign-items 纵轴对齐方式，默认是纵轴\n\n\n优点： 简单、方便、快速，三行代码搞定。\n\n## 2.flex-给子项设置\n第一种方式是给父盒子设置属性，这一种是给子盒子设置margin: auto实现居中。\n\n给容器设置 display: flex; 子项设置 margin: auto;\n\n## 3.绝对定位\n使用绝对定位的方式实现水平垂直居中。容器设置position: relative。子元素设置 position: absolute; left: 50%; top: 50%; transfrom: translate(-50%, -50%);\n\n优点就是不用关心子元素的长和宽，但是这种方法兼容性依赖translate2d的兼容性\n\n## 4.tabel-cell实现垂直居中\ncss新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中\n而且tabel单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了\n\n\n使用tabel-cell实现垂直居中,容器设置 display: table-cell;;\n\n\n vertical-align: middle属性设置元素的垂直对齐方式\n\n\n子元素如果是块级元素，直接使用左右margin:auto实现水平居中。如果是行内元素，给容器设置text-align: center\n\n\n利用 text-align: center 可以实现在块级元素内部的内联元素水平居中。此方法对内联元素inline, 内联块inline-block, 内联表inline-table, inline-flex元素水平居中都有效。\n\n\n## 5.grid设置居中\n使用grid设置居中。给容器设置 display: grid; align-items: center; justify-content: center;\n\n通过给容器设置属性，达到居中效果,但是这种方式兼容性较差，不推荐。\n\n## 6.grid给子项设置\n使用grid时还能通过给子项设置margin: auto;实现居中。给容器设置 display: grid; 子项设置 margin: auto;\n\n某些浏览器会不支持grid布局方式，兼容性较差，不推荐。\n\n## 7.给容器加给伪元素\n这是一种不常用的方法实现垂直居中。给容器加给伪元素，设置line-height等于容器的高度。给孩子设置display: inline-block;\n\n此种方式适合给文本设置水平垂直居中\n\n## 8.还有一种奇葩的方法\n这个奇葩方式和第三种使用绝对定位相似，只不过需要给子元素设置 position: absolute; 设置固定宽度和高度;top、left、bottom、right都设置为0; margin设置为auto；也能实现垂直水平居中。\n', '我已经说了5种css居中实现的方式了，面试官竟然说还不够？', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659018450000.jpg');
INSERT INTO `article` VALUES (130, 2, '2022-07-28 22:38:52', '<h2><a id=\"_2\"></a>什么是模型可视化？</h2>\n<p>模型可视化提供了模型背后的原因和逻辑，以实现模型的问责和透明度。由于复杂的内部工作原理，机器学习模型被视为黑盒模型。数据科学家提供了一个高精度的模型。在某些情况下，模型无法向公众解释，因为系统可能会被非法侵入。</p>\n<p>数据可视化技术使用图表和图形来可视化大量复杂数据。单击以探索高级的数据可视化技术及其功能。</p>\n<p>不同类型的模型可视化描述如下：</p>\n<ul>\n<li>数据探索 - 数据探索是使用探索性数据分析 (EDA) 完成的。应用 T 分布随机邻域嵌入 (t-SNE) 或主成分分析 (PCA) 技术来理解特征。</li>\n<li>构建模型 - 用于衡量分类和回归模型的各种指标。分类中使用的准确率、精确率和召回率、混淆矩阵、对数损失和 F1 值，而回归中使用的均方误差 (MSE)、均方对数误差、均方根误差 (RMSE)。建立模型后的所有这些指标都用于理解和衡量性能。</li>\n<li>决策树模型 - 静态特征摘要，例如：从模型中检索到的特征重要性。它仅存在于基于决策树的算法中，例如：随机森林和 XGBoost。</li>\n<li>评估模型 - 评估模型的错误预测。</li>\n</ul>\n<h2><a id=\"_14\"></a>训练期间的模型可视化</h2>\n<p>在模型的训练过程中，需要将训练过程可视化，有助于理解调试模型，跟踪模型的错误和进度。可视化每个步骤的测试和训练结果值。</p>\n<ul>\n<li>标量（Scalars） - 标量可用于显示训练期间的误差趋势。除了定期将损失和准确率记录到标准输出之外，我们还会记录并绘制它们以分析其长期趋势。</li>\n<li>直方图（Histograms） - 可视化模型图中张量的分布如何随时间变化。显示张量在不同时间点的许多直方图可视化。</li>\n<li>权重和偏差（Weight and bias） - 通过在直方图上可视化权重和偏差来监控训练期间的权重和偏差。</li>\n<li>激活（Activation） - 为了使梯度下降发挥最佳效果，节点输出通常在激活函数之前分发。</li>\n<li>梯度（Gradients） - 可以对每一层的梯度进行可视化，以识别深度学习问题，如梯度减少或爆炸问题。</li>\n<li>图表（Graphs） - 通过图表来可视化模型的内部结构或架构。</li>\n<li>图像（Image） - 训练每一步的图像意味着生成的中间图像可以可视化并可视化张量。</li>\n<li>投影（Projector） - 用于将高维向量进行可视化，可视化主成分分析（PCA）和 T-SNE 算法模型结果。该技术主要用于降维。将高维向量投影到三维坐标系。</li>\n</ul>\n<h2><a id=\"_26\"></a>为什么模型可视化很重要？</h2>\n<p>仅仅是准确率不会给出模型的准确解释。我们需要测试模型的准确性并相信分类器或模型工作正常。</p>\n<ul>\n<li>对模型在做什么的正确解释？</li>\n<li>为什么结果是这样的？</li>\n<li>以向非技术人员描述的形式或视觉形式输出。</li>\n</ul>\n<p>开发机器学习模型的示例：</p>\n<p>开发用于医疗诊断目的的机器学习模型，仅测试样本的高精度或更少的错误可能不足以将它们出售给临床医生。医生和患者都不太愿意相信他们不理解的模型做出的决定。</p>\n<p>我们需要在大多数情况下进行解释，因为：</p>\n<ul>\n<li>可信度——如果使用分类或预测结果，需要一些领域知识，如股票交易员才能理解，以提供购买或出售特定股票的决策。</li>\n<li>透明度——机器学习不能是一个黑盒子，应该为客户、消费者和管理层提供模型结构、清晰度。就像开源一样，模型理解应该是开源的。</li>\n<li>负责任 - 模型应该有责任向消费者提供正确的答案。作为模型所有者，我们应该验证模型特征以保证其有助于做出决策。</li>\n</ul>\n<h2><a id=\"_43\"></a>模型可视化如何工作？</h2>\n<p>分类/回归机器学习模型的结果或决策很难被人脑理解。这也使得向非数据科学家解释变得困难。复杂模型功能可以通过将线性模型局部拟合到训练集的某些排列来近似。</p>\n<h3><a id=\"LIME_45\"></a>LIME</h3>\n<p>LIME 是一种算法，用于解释分类器或回归模型的预测。它给出了带有视觉解释的特征列表，需要视觉形式的特征重要性来确定数据集中的基本元素。 LIME 提供模型的可视化描述并解释实际模型正在实现的内容。</p>\n<h3><a id=\"_47\"></a>模型预测示例：</h3>\n<p>模型预测特定患者患有流感。然后由解释器解释预测，该解释器突出显示对模型很重要的症状。借助有关模型背后原理的这些信息，医生现在有权信任或不信任该模型。</p>\n<h3><a id=\"GradCAM_49\"></a>Grad-CAM</h3>\n<p>梯度加权类激活图是一种先进且专业的方法。这种方法的一些限制是我们需要访问模型的内部，并且它应该与图像一起使用。为了简单地理解该方法，给定一个数据样本（图像），它将以神经网络具有最多和最大激活的图像区域的热力图的形式给出输出，因此，图像中的特征在模型中与类相关。</p>\n<h3><a id=\"SHAP_52\"></a>SHAP</h3>\n<p>SHAP 为不同类型的模型提供了许多解释器。</p>\n<ul>\n<li>Tree Explainer - 通过 Tree SHAP 支持 XGBoost、LightGBM、CatBoost 和 scikit-learn模型。</li>\n<li>Deep Explainer(DEEP SHAP) - 通过使用 Deeplift 和 Shapley 值支持 Tensorflow 和 Keras 模型。</li>\n<li>Gradient Explainer - 支持 Tensorflow 和 Keras 模型。</li>\n<li>Kernel Explainer (kernel SHAP) - 使用 LIME 和 Shapley 值应用于任何模型。</li>\n</ul>\n<h3><a id=\"_60\"></a>决策树可视化</h3>\n<p>决策树模型可以在决策树的帮助下轻松可视化或解释。它允许浏览每个单独的树以查看它们对整个模型的相对重要性。回答每个特征对特定树的重要性的问题。</p>\n<p>以下是独特的可视化特征：</p>\n<ul>\n<li>决策节点显示特征空间如何分割。</li>\n<li>决策节点的分割位置在分布中直观地显示。</li>\n<li>在模型中，它可视化了训练数据或样本如何分布在叶节点中，以及树如何对特定观察进行预测。</li>\n</ul>\n<h3><a id=\"_69\"></a>模型结构可视化</h3>\n<ul>\n<li>通过深度可视化了解神经网络。</li>\n<li>显示每一层、激活、权重。</li>\n</ul>\n<h3><a id=\"_74\"></a>神经网络行为的可视化</h3>\n<p>人工神经网络的可视化采用静态节点链接图的形式，它可视化网络的结构，而不是模型的动作。</p>\n<p>神经网络的可视化已训练数字识别模型，显示给定用户提供输入的网络的实际行为。用户通过绘图板与网络进行交互，并实时观察网络的激活模式。</p>\n', '机器学习模型可视化类型和工具', NULL, 1, 0, 2, '2022-07-28 23:15:24', '\n\n## 什么是模型可视化？\n模型可视化提供了模型背后的原因和逻辑，以实现模型的问责和透明度。由于复杂的内部工作原理，机器学习模型被视为黑盒模型。数据科学家提供了一个高精度的模型。在某些情况下，模型无法向公众解释，因为系统可能会被非法侵入。\n\n数据可视化技术使用图表和图形来可视化大量复杂数据。单击以探索高级的数据可视化技术及其功能。\n\n不同类型的模型可视化描述如下：\n\n- 数据探索 - 数据探索是使用探索性数据分析 (EDA) 完成的。应用 T 分布随机邻域嵌入 (t-SNE) 或主成分分析 (PCA) 技术来理解特征。\n- 构建模型 - 用于衡量分类和回归模型的各种指标。分类中使用的准确率、精确率和召回率、混淆矩阵、对数损失和 F1 值，而回归中使用的均方误差 (MSE)、均方对数误差、均方根误差 (RMSE)。建立模型后的所有这些指标都用于理解和衡量性能。\n- 决策树模型 - 静态特征摘要，例如：从模型中检索到的特征重要性。它仅存在于基于决策树的算法中，例如：随机森林和 XGBoost。\n- 评估模型 - 评估模型的错误预测。\n\n## 训练期间的模型可视化\n在模型的训练过程中，需要将训练过程可视化，有助于理解调试模型，跟踪模型的错误和进度。可视化每个步骤的测试和训练结果值。\n\n- 标量（Scalars） - 标量可用于显示训练期间的误差趋势。除了定期将损失和准确率记录到标准输出之外，我们还会记录并绘制它们以分析其长期趋势。\n- 直方图（Histograms） - 可视化模型图中张量的分布如何随时间变化。显示张量在不同时间点的许多直方图可视化。\n- 权重和偏差（Weight and bias） - 通过在直方图上可视化权重和偏差来监控训练期间的权重和偏差。\n- 激活（Activation） - 为了使梯度下降发挥最佳效果，节点输出通常在激活函数之前分发。\n- 梯度（Gradients） - 可以对每一层的梯度进行可视化，以识别深度学习问题，如梯度减少或爆炸问题。\n- 图表（Graphs） - 通过图表来可视化模型的内部结构或架构。\n- 图像（Image） - 训练每一步的图像意味着生成的中间图像可以可视化并可视化张量。\n- 投影（Projector） - 用于将高维向量进行可视化，可视化主成分分析（PCA）和 T-SNE 算法模型结果。该技术主要用于降维。将高维向量投影到三维坐标系。\n\n## 为什么模型可视化很重要？\n仅仅是准确率不会给出模型的准确解释。我们需要测试模型的准确性并相信分类器或模型工作正常。\n\n- 对模型在做什么的正确解释？\n- 为什么结果是这样的？\n- 以向非技术人员描述的形式或视觉形式输出。\n\n开发机器学习模型的示例：\n\n开发用于医疗诊断目的的机器学习模型，仅测试样本的高精度或更少的错误可能不足以将它们出售给临床医生。医生和患者都不太愿意相信他们不理解的模型做出的决定。\n\n我们需要在大多数情况下进行解释，因为：\n\n- 可信度——如果使用分类或预测结果，需要一些领域知识，如股票交易员才能理解，以提供购买或出售特定股票的决策。\n- 透明度——机器学习不能是一个黑盒子，应该为客户、消费者和管理层提供模型结构、清晰度。就像开源一样，模型理解应该是开源的。\n- 负责任 - 模型应该有责任向消费者提供正确的答案。作为模型所有者，我们应该验证模型特征以保证其有助于做出决策。\n\n## 模型可视化如何工作？\n分类/回归机器学习模型的结果或决策很难被人脑理解。这也使得向非数据科学家解释变得困难。复杂模型功能可以通过将线性模型局部拟合到训练集的某些排列来近似。\n### LIME\nLIME 是一种算法，用于解释分类器或回归模型的预测。它给出了带有视觉解释的特征列表，需要视觉形式的特征重要性来确定数据集中的基本元素。 LIME 提供模型的可视化描述并解释实际模型正在实现的内容。\n### 模型预测示例：\n模型预测特定患者患有流感。然后由解释器解释预测，该解释器突出显示对模型很重要的症状。借助有关模型背后原理的这些信息，医生现在有权信任或不信任该模型。\n### Grad-CAM\n梯度加权类激活图是一种先进且专业的方法。这种方法的一些限制是我们需要访问模型的内部，并且它应该与图像一起使用。为了简单地理解该方法，给定一个数据样本（图像），它将以神经网络具有最多和最大激活的图像区域的热力图的形式给出输出，因此，图像中的特征在模型中与类相关。\n\n### SHAP\nSHAP 为不同类型的模型提供了许多解释器。\n\n- Tree Explainer - 通过 Tree SHAP 支持 XGBoost、LightGBM、CatBoost 和 scikit-learn模型。\n- Deep Explainer(DEEP SHAP) - 通过使用 Deeplift 和 Shapley 值支持 Tensorflow 和 Keras 模型。\n- Gradient Explainer - 支持 Tensorflow 和 Keras 模型。\n- Kernel Explainer (kernel SHAP) - 使用 LIME 和 Shapley 值应用于任何模型。\n\n### 决策树可视化\n决策树模型可以在决策树的帮助下轻松可视化或解释。它允许浏览每个单独的树以查看它们对整个模型的相对重要性。回答每个特征对特定树的重要性的问题。\n\n以下是独特的可视化特征：\n\n- 决策节点显示特征空间如何分割。\n- 决策节点的分割位置在分布中直观地显示。\n- 在模型中，它可视化了训练数据或样本如何分布在叶节点中，以及树如何对特定观察进行预测。\n\n### 模型结构可视化\n\n- 通过深度可视化了解神经网络。\n- 显示每一层、激活、权重。\n\n### 神经网络行为的可视化\n人工神经网络的可视化采用静态节点链接图的形式，它可视化网络的结构，而不是模型的动作。\n\n神经网络的可视化已训练数字识别模型，显示给定用户提供输入的网络的实际行为。用户通过绘图板与网络进行交互，并实时观察网络的激活模式。\n\n', '携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第1天，点击查看活动详情', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659019127000.jpg');
INSERT INTO `article` VALUES (131, 2, '2022-07-28 22:45:19', '<p>《底层逻辑》把智慧分为三个层次：博弈、定力、选择。<br />\n博弈：代表你要用双赢的思维，去赢得你选择赛道的胜利。<br />\n定力：代表你要坚定自己选择的赛道，不随意更换，来赢得长期的红利。<br />\n选择：代表你的选择要能顺应时代的趋势，做正确的事要比正确的做事更重要。<br />\n而这个时代的趋势，选择“机器学习”这个赛道就是正确的事，可能远远比你在工程领域去正确的做事，能收获更大的时代红利。让我产生这个想法，也是自己在招聘市场看到的现象，我们项目组要同时招聘Java工程师和算法工程师，从薪资、经验、发展三个方向来看，算法工程师这个职位都是完胜的。</p>\n<ul>\n<li>薪资：Java工程师的顶薪只是算法工程师的起薪。</li>\n<li>经验：Java工程师市场供给远远大于需求，企业挑选人才的标准也就高了，不仅要毕业学校好，还要有大厂经历。而算法工程师，明显市场需求大于供给，有名校和大厂毕业的就更少了，企业挑选人才的范围少了，要求自然不会有这么高。</li>\n<li>发展：算法这个行业更看重你底层的功底和能力，未来更注重你思维逻辑和算法经验；而不像工程可能还存在拼体力的过程，任务紧张，需要你去拼时间来完成工作量。</li>\n</ul>\n<p>虽然如此，但是要你再在一个新的领域重新开始时，你依然会纠结和彷徨，再三对比和衡量得失。时代的趋势在不停向前发展，大的方向其实大家心里都或多或少有所了解，那就从此刻开始改变吧，人生最好开始的时刻要么在10年前，要么在此刻。</p>\n<h2><a id=\"_12\"></a>我理解的“机器学习”</h2>\n<p>机器学习学的是输入和输出之间的映射关系，这种映射关系最后会以模型的形式展现。</p>\n<p>那么模型就可以表示为：输入输出符合的概率分布，或者输入输出之间的数量关系。从数据的角度看，如果这个模型可以用一组有限且固定数目的参数完全刻画，求出的模型就是参数模型；反过来，不满足这个条件的模型就是非参数模型。</p>\n<h3><a id=\"_16\"></a>参数模型</h3>\n<p>参数模型优势在于只用少量参数就可以完整地刻画出数据的概率特性，每个参数都具有明确的统计意义。经典的数学模型包括：典型概率分布，离散变量的二项分布B(n,p)只包含两个参数，分别代表：独立重复试验的次数和每次试验中事件发生的概率。</p>\n<p>为什么参数模型中，有限的参数就能够描述无限的数据呢？</p>\n<p>来源于超强的先验假设，所有数据符合特定类型的概率分布。在实际的学习任务中，我们并非对问题一无所知，通常都具有一定的先验知识。先验知识并不源于对数据的观察，而是先于数据存在，参数模型正好就是先验知识的体现和应用。</p>\n<p>参数模型虽然简单实用，但其得到的结论就一定可信？</p>\n<p>参数模型的可信度依赖于先验知识的可信度。如果先验知识可信度本身就不符合实际，那么不管训练数据集的体量多大，学习算法的性能多强，学习出来的结果都会与事实真相南辕北辙，背道而驰。</p>\n<p>当对所要学习的问题知之甚少的时候，就不要使用先验信息。</p>\n<h3><a id=\"_30\"></a>非参数模型</h3>\n<p>不依赖于先验经验，完全靠数据进行学习得到的模型就是非参数模型。</p>\n<p>非参数模型意味着模型参数的数目是不固定的，并且极有可能是无穷大，这决定了非参数模型不可能像参数模型那样用固定且有限数目的参数完全刻画出来。</p>\n<p>非参数模型不存在关于数据潜在模式和结构化特性的任何假设，数据的所有统计都源于数据本身，所见即所得。</p>\n<p>因此对比参数模型，非参数模型的时空复杂度都会比参数模型大得多。但可以证明的是，当训练数据趋于无穷多时，非参数模型可以逼近任意复杂的真实模型。</p>\n<h2><a id=\"_39\"></a>更系统和专业的概念</h2>\n<p>非参数模型可以理解为一种局部模型。在局部上，相似的输入会得到相似的输出，而全局的分布就是所有局部分布的叠加。</p>\n<p>参数模型具有全局的特性。所有数据都满足统一的全局分布，一组全局分布的参数就可以表示所有的数据。</p>\n<p>从模型构造的角度来看，参数模型对应的就是数据模型，非参数模型对应的就是算法模型。</p>\n<p>著名统计学家布雷曼，最看重的就是学习算法从数据中获取有用结论和展示数据规律的能力。从一点出发，将输入x和输出y的关系看成黑盒。数据模型认为这个黑盒里装着一组未知的参数，学习的对象是这组参数；算法模型则认为这个黑盒里装着一个未知的映射函数，学习的对象就是这个映射函数。</p>\n<p>数据模型最典型的方法是线性回归，输出结果表示为输入特征的线性加权组合，算法通过训练数据来学习权重系数。</p>\n<p>算法模型最典型的方法是随机森林算法，随机森林是一种集成学习方法，构成这座森林的每一颗树都是决策树，每一颗决策树都用随机选取数据和待选特征构造出来，再按照少数服从多数的原则从所有决策树的结果中得到最终输出。</p>\n<p>决策树本身是具有较好的可解释性的数据模型，它表示的是几何意义上的对特征空间的划分，但是精确度却不堪理想。随机森林解决了这个问题：通过综合使用建立在同一个数据集上的不同决策树达到出人意料的良好效果，在精确度上提升了数倍，但换来的就是可解释性的下降。</p>\n<p>从学习方法上看，数据模型和算法模型具有相同的本质。此外还有一种针对学习对象的划分方式，就是生成模型和判别模型之分。</p>\n<ul>\n<li>生成模型：学习的对象是输入x和输出y的联合分布p(x,y)。</li>\n<li>判别模型：学习的则是已知输入x的条件下，输出y的条件分布p(y|x)。</li>\n</ul>\n<p>这两个模型可以通过贝叶斯定理建立联系。</p>\n<p>生成模型的求解更加复杂，当数据量趋于无穷大时，渐进条件下的精确性也更差，但其收敛的速度更快，在较少数据的训练后就可以收敛到错误的下限。</p>\n<p>判别模型更加简单，在分类问题上的表现也更差，却不能提供关于数据生成机制的信息。</p>\n<p>当下，参数模型还是机器学习的主流，非参数模型在应用范围上还是性能表现上都要略逊一筹。</p>\n<h2><a id=\"_67\"></a>后续计划</h2>\n<ul>\n<li>\n<p>模型的设计准则</p>\n</li>\n<li>\n<p>模型的验证方法</p>\n</li>\n<li>\n<p>模型的评估指标</p>\n</li>\n<li>\n<p>实验设计</p>\n</li>\n</ul>\n', '机器学习开篇之路', NULL, 1, 0, 3, '2022-07-28 23:17:14', '《底层逻辑》把智慧分为三个层次：博弈、定力、选择。\n博弈：代表你要用双赢的思维，去赢得你选择赛道的胜利。\n定力：代表你要坚定自己选择的赛道，不随意更换，来赢得长期的红利。\n选择：代表你的选择要能顺应时代的趋势，做正确的事要比正确的做事更重要。\n而这个时代的趋势，选择“机器学习”这个赛道就是正确的事，可能远远比你在工程领域去正确的做事，能收获更大的时代红利。让我产生这个想法，也是自己在招聘市场看到的现象，我们项目组要同时招聘Java工程师和算法工程师，从薪资、经验、发展三个方向来看，算法工程师这个职位都是完胜的。\n\n- 薪资：Java工程师的顶薪只是算法工程师的起薪。\n- 经验：Java工程师市场供给远远大于需求，企业挑选人才的标准也就高了，不仅要毕业学校好，还要有大厂经历。而算法工程师，明显市场需求大于供给，有名校和大厂毕业的就更少了，企业挑选人才的范围少了，要求自然不会有这么高。\n- 发展：算法这个行业更看重你底层的功底和能力，未来更注重你思维逻辑和算法经验；而不像工程可能还存在拼体力的过程，任务紧张，需要你去拼时间来完成工作量。\n\n虽然如此，但是要你再在一个新的领域重新开始时，你依然会纠结和彷徨，再三对比和衡量得失。时代的趋势在不停向前发展，大的方向其实大家心里都或多或少有所了解，那就从此刻开始改变吧，人生最好开始的时刻要么在10年前，要么在此刻。\n\n## 我理解的“机器学习”\n机器学习学的是输入和输出之间的映射关系，这种映射关系最后会以模型的形式展现。\n\n那么模型就可以表示为：输入输出符合的概率分布，或者输入输出之间的数量关系。从数据的角度看，如果这个模型可以用一组有限且固定数目的参数完全刻画，求出的模型就是参数模型；反过来，不满足这个条件的模型就是非参数模型。\n### 参数模型\n\n参数模型优势在于只用少量参数就可以完整地刻画出数据的概率特性，每个参数都具有明确的统计意义。经典的数学模型包括：典型概率分布，离散变量的二项分布B(n,p)只包含两个参数，分别代表：独立重复试验的次数和每次试验中事件发生的概率。\n\n为什么参数模型中，有限的参数就能够描述无限的数据呢？\n\n来源于超强的先验假设，所有数据符合特定类型的概率分布。在实际的学习任务中，我们并非对问题一无所知，通常都具有一定的先验知识。先验知识并不源于对数据的观察，而是先于数据存在，参数模型正好就是先验知识的体现和应用。\n\n参数模型虽然简单实用，但其得到的结论就一定可信？\n\n参数模型的可信度依赖于先验知识的可信度。如果先验知识可信度本身就不符合实际，那么不管训练数据集的体量多大，学习算法的性能多强，学习出来的结果都会与事实真相南辕北辙，背道而驰。\n\n当对所要学习的问题知之甚少的时候，就不要使用先验信息。\n\n### 非参数模型\n不依赖于先验经验，完全靠数据进行学习得到的模型就是非参数模型。\n\n非参数模型意味着模型参数的数目是不固定的，并且极有可能是无穷大，这决定了非参数模型不可能像参数模型那样用固定且有限数目的参数完全刻画出来。\n\n非参数模型不存在关于数据潜在模式和结构化特性的任何假设，数据的所有统计都源于数据本身，所见即所得。\n\n因此对比参数模型，非参数模型的时空复杂度都会比参数模型大得多。但可以证明的是，当训练数据趋于无穷多时，非参数模型可以逼近任意复杂的真实模型。\n\n## 更系统和专业的概念\n非参数模型可以理解为一种局部模型。在局部上，相似的输入会得到相似的输出，而全局的分布就是所有局部分布的叠加。\n\n参数模型具有全局的特性。所有数据都满足统一的全局分布，一组全局分布的参数就可以表示所有的数据。\n\n从模型构造的角度来看，参数模型对应的就是数据模型，非参数模型对应的就是算法模型。\n\n著名统计学家布雷曼，最看重的就是学习算法从数据中获取有用结论和展示数据规律的能力。从一点出发，将输入x和输出y的关系看成黑盒。数据模型认为这个黑盒里装着一组未知的参数，学习的对象是这组参数；算法模型则认为这个黑盒里装着一个未知的映射函数，学习的对象就是这个映射函数。\n\n数据模型最典型的方法是线性回归，输出结果表示为输入特征的线性加权组合，算法通过训练数据来学习权重系数。\n\n算法模型最典型的方法是随机森林算法，随机森林是一种集成学习方法，构成这座森林的每一颗树都是决策树，每一颗决策树都用随机选取数据和待选特征构造出来，再按照少数服从多数的原则从所有决策树的结果中得到最终输出。\n\n决策树本身是具有较好的可解释性的数据模型，它表示的是几何意义上的对特征空间的划分，但是精确度却不堪理想。随机森林解决了这个问题：通过综合使用建立在同一个数据集上的不同决策树达到出人意料的良好效果，在精确度上提升了数倍，但换来的就是可解释性的下降。\n\n从学习方法上看，数据模型和算法模型具有相同的本质。此外还有一种针对学习对象的划分方式，就是生成模型和判别模型之分。\n\n- 生成模型：学习的对象是输入x和输出y的联合分布p(x,y)。\n- 判别模型：学习的则是已知输入x的条件下，输出y的条件分布p(y|x)。\n\n这两个模型可以通过贝叶斯定理建立联系。\n\n生成模型的求解更加复杂，当数据量趋于无穷大时，渐进条件下的精确性也更差，但其收敛的速度更快，在较少数据的训练后就可以收敛到错误的下限。\n\n判别模型更加简单，在分类问题上的表现也更差，却不能提供关于数据生成机制的信息。\n\n当下，参数模型还是机器学习的主流，非参数模型在应用范围上还是性能表现上都要略逊一筹。\n\n## 后续计划\n- 模型的设计准则\n \n- 模型的验证方法\n\n- 模型的评估指标\n\n- 实验设计', '我要学机器学习，我要飞的更高', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659019517000.jpg');
INSERT INTO `article` VALUES (132, 4, '2022-07-28 22:54:50', '<div class=\"hljs-center\">\n<h1><a id=\"Java_2\"></a>Java基础知识</h1>\n</div>\n<h2><a id=\"_6\"></a>何为编程</h2>\n<p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并 终得到结果的过程。</p>\n<p>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、 和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一 步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编 程。</p>\n<h2><a id=\"Java_10\"></a>什么是Java</h2>\n<p>Java是一门面向对象编程语言，不仅吸收了C<ins>语言的各种优点，还摒弃了 C</ins>里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易 用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对 象理论，允许程序员以优雅的思维方式进行复杂的编程</p>\n<h2><a id=\"jdk15_12\"></a>jdk1.5之后的三大版本</h2>\n<ul>\n<li>\n<p>Java SE（J2SE，Java 2 Platform Standard Edition，标准版） Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使 用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</p>\n</li>\n<li>\n<p>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版） Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器 端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、 管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名 为 JakartaEE</p>\n</li>\n<li>\n<p>Java ME（J2ME，Java 2 Platform Micro Edition，微型版） Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视 机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用 户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序 的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可 以利用每个设备的本机功能。</p>\n</li>\n</ul>\n<h2><a id=\"JVMJREJDK_20\"></a>JVM、JRE和JDK的关系</h2>\n<h3><a id=\"JVM_21\"></a>JVM</h3>\n<p>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此Java语言可以实现跨平台。</p>\n<h3><a id=\"JRE_23\"></a>JRE</h3>\n<p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核 心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数 据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p>\n<p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>\n<h3><a id=\"JDK_27\"></a>JDK</h3>\n<p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发 工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工 具：编译工具(javac.exe)，打包工具(jar.exe)等</p>\n', 'Java基础知识', NULL, 1, 0, 2, '2022-07-28 23:15:03', '::: hljs-center\n\n# Java基础知识\n\n:::\n\n## 何为编程\n编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并 终得到结果的过程。\n\n为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、 和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一 步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编 程。\n## 什么是Java\nJava是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了 C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易 用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对 象理论，允许程序员以优雅的思维方式进行复杂的编程 \n## jdk1.5之后的三大版本\n\n- Java SE（J2SE，Java 2 Platform Standard Edition，标准版） Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使 用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。\n\n- Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版） Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器 端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、 管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名 为 JakartaEE\n\n- Java ME（J2ME，Java 2 Platform Micro Edition，微型版） Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视 机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用 户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序 的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可 以利用每个设备的本机功能。\n\n## JVM、JRE和JDK的关系\n### JVM\nJava Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此Java语言可以实现跨平台。\n### JRE\nJava Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核 心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数 据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包\n\n如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。\n### JDK\nJava Development Kit是提供给Java开发人员使用的，其中包含了Java的开发 工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工 具：编译工具(javac.exe)，打包工具(jar.exe)等\n\n', 'java基础知识第一天总结', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659020086000.jpg');
INSERT INTO `article` VALUES (133, 4, '2022-07-28 23:05:49', '<h2><a id=\"_0\"></a>我们想要什么样的人？</h2>\n<p>老三在一家跨境电商，不是什么知名大厂，我们招人的第一标准：</p>\n<h3><a id=\"_3\"></a>能干活</h3>\n<p>给老三排的面试，候选人的经验基本是1-5年，招聘的级别大概是中级/高级开发这样子，所以招来的人是要能即插即用的。</p>\n<p>能干好活是底线，或者说白了，CRUD能写地溜，能解决问题。</p>\n<p>候选人肯定是要有一定的项目经验，项目最好有一定并发量，电商相关的更好。</p>\n<p>技术方面，Java基础、框架之类的不用多说，数据库也是必需，常见的中间件Redis、RocketMQ之类，也要知道怎么用，用在哪里。</p>\n<p>能干好活是一条合格线，只有过了这条合格线，再说哪些能加分的亮点，或者减分的缺点。</p>\n<h3><a id=\"_15\"></a>能相处</h3>\n<p>招人，招进来之后是要经常合作的，谁也不希望招进来一个不靠谱，让人上头的。</p>\n<p>虽然说，我们不会搞一堆没用的性格测试，但是面试的时候，还是会看看候选人的沟通能力，还有——感觉。说真的，面试的时候，看人都是有感觉的，有的人，你就是感觉很强，有的就是感觉很好相处，也有的就是感觉不靠谱……</p>\n<p>当然，说句实在话，每场面试一个小时，前后几轮加起来也不过几个小时，而且大家都是有“演技”的，面试官的感觉也很主观，走眼也是难免的。比如前一阵子，就有个小伙，入职三天，发现这个人很不靠谱，直接劝退了。</p>\n<p>剩下的就是找候选人的亮点——项目有东西、熟悉源码、实战能力强、基础扎实、算法能力强……</p>\n<h2><a id=\"_25\"></a>我们看学历和背景吗？</h2>\n<p>我个人感觉，在社招中：能力&gt;背景&gt;学历。</p>\n<p>如果学历比较好，有大厂背景，毫无疑问是加分项。但是，最主要的还是看能力，剩下的再看这些加分项。</p>\n<p>老三面过两个九八五的硕士，一个之前在菊厂，一个在熊厂，按理说985+大厂，面试不是so easy？但是挂了。</p>\n<p>因为一个在菊厂，写的都是偏操作系统方向的东西，一个在熊厂，写PHP，内部项目，项目基本不匹配。技术呢，Java技术栈了解不多，结果计算机基础也不太行，算法也写的不好，那这……</p>\n<p>当然也有学历三本，实力非常强，每轮面试完全是乱杀，面评技术分直接拉到最高的大佬。</p>\n<p>再说一点题外话，今年的裁员，对去年的毕业生真的挺不好，一年不到的经验，社招挺尴尬的。</p>\n', '面了三十个人，说说我的真实感受', NULL, 1, 0, 5, '2022-07-28 23:51:49', '## 我们想要什么样的人？\n老三在一家跨境电商，不是什么知名大厂，我们招人的第一标准：\n\n### 能干活\n\n给老三排的面试，候选人的经验基本是1-5年，招聘的级别大概是中级/高级开发这样子，所以招来的人是要能即插即用的。\n\n能干好活是底线，或者说白了，CRUD能写地溜，能解决问题。\n\n候选人肯定是要有一定的项目经验，项目最好有一定并发量，电商相关的更好。\n\n技术方面，Java基础、框架之类的不用多说，数据库也是必需，常见的中间件Redis、RocketMQ之类，也要知道怎么用，用在哪里。\n\n能干好活是一条合格线，只有过了这条合格线，再说哪些能加分的亮点，或者减分的缺点。\n\n### 能相处\n\n招人，招进来之后是要经常合作的，谁也不希望招进来一个不靠谱，让人上头的。\n\n虽然说，我们不会搞一堆没用的性格测试，但是面试的时候，还是会看看候选人的沟通能力，还有——感觉。说真的，面试的时候，看人都是有感觉的，有的人，你就是感觉很强，有的就是感觉很好相处，也有的就是感觉不靠谱……\n\n当然，说句实在话，每场面试一个小时，前后几轮加起来也不过几个小时，而且大家都是有“演技”的，面试官的感觉也很主观，走眼也是难免的。比如前一阵子，就有个小伙，入职三天，发现这个人很不靠谱，直接劝退了。\n\n剩下的就是找候选人的亮点——项目有东西、熟悉源码、实战能力强、基础扎实、算法能力强……\n\n## 我们看学历和背景吗？\n我个人感觉，在社招中：能力>背景>学历。\n\n如果学历比较好，有大厂背景，毫无疑问是加分项。但是，最主要的还是看能力，剩下的再看这些加分项。\n\n老三面过两个九八五的硕士，一个之前在菊厂，一个在熊厂，按理说985+大厂，面试不是so easy？但是挂了。\n\n因为一个在菊厂，写的都是偏操作系统方向的东西，一个在熊厂，写PHP，内部项目，项目基本不匹配。技术呢，Java技术栈了解不多，结果计算机基础也不太行，算法也写的不好，那这……\n\n当然也有学历三本，实力非常强，每轮面试完全是乱杀，面评技术分直接拉到最高的大佬。\n\n再说一点题外话，今年的裁员，对去年的毕业生真的挺不好，一年不到的经验，社招挺尴尬的。\n\n', '大家好，我是老三。\n\n今年的金三银四，比以往要惨淡一些，但是老三还是面试了小三十个人，过了把面试官的瘾，接下来，我会用自问自答的方式，聊聊作为一个面试官的真实感受', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659020747000.jpg');
INSERT INTO `article` VALUES (134, 4, '2022-07-28 23:10:40', '<h2><a id=\"_0\"></a>首先，要注意排版</h2>\n<p>在写代码时注意排版，保持一致的缩进风格，并利用空行划分段落，可以让代码看起来更整洁，逻辑更清晰。</p>\n<p>在一个较复杂的方法中，将方法中各个处理步骤用空行进行分隔，可以让代码具备很好的可读性。如果一个方法中几十行代码完全没有分隔，密密麻麻挤在一起，阅读这段代码会让人感觉像是在看一篇没有标点符号的文章，让人喘过不气来。</p>\n<p>下面这段代码，正确使用了空行进行分隔，看起来非常轻松。</p>\n<p>合适的空行，让阅读者知道上一个处理步骤已结束，开始下一个处理步骤了。在阅读代码时，就可以按空行跳跃进行查看，快速找到关注的点。</p>\n<p>统一的缩进格式会让代码看起来整齐划一，非常清爽。阅读这样的代码时，会让人心情愉悦，频频赞许。</p>\n<h2><a id=\"_11\"></a>其次，让代码具备自描述性</h2>\n<p>好的代码应该具备自描述性。正如上面提到的，阅读代码就像是阅读一篇文章，好的文章是不需要一边看内容，一边看下面的脚注来理解的。</p>\n<p>在接手一个项目时，被吐槽最多的是代码没有注释。但注释过多也是另一个极端，不应该被提倡。过多的注释也会成为项目的一个负担，每次修改代码时必须要记得同步修改注释，如果忘记修改注释，出现注释和代码不一致的情形，就会让人对注释失去信任。经常出现这样的情况，就会让开发变得越来越不愉快了。</p>\n<p>当打算写注释时，先思考一下，这里是否能用代码本身来把逻辑表达出来。在确定这是一种特殊情况，需要交代为何如此处理的背景信息时，才应该写注释。正常情况下，都可以通过方法，变量的命名来描述清楚。</p>\n<p>比如下面这样的代码，命名，结构都非常清晰易懂</p>\n<p>有时为了想一个好名字也要花上一些时间，但这是值得的。良好的命名可以让代码更加易读。类名，方法名，参数名，变量名都是我们可以利用的载体，可以通过这些名称来把代码逻辑表达出来。</p>\n<h2><a id=\"_22\"></a>最后，可以做的还有很多</h2>\n<p>让代码简洁易读并不容易，大道至简，是要花很多心思的，这个话题也不是一篇短文可以讲完的。这里再提供几个小方法，希望可以起到抛砖引玉的作用。</p>\n<ul>\n<li>一个方法只做一件事情，并保证方法名准确，参数及返回值明确</li>\n</ul>\n<p>一个方法应尽可能短，非必要不要超过 80 行。当超过时，就需要提醒自己，是不是在方法中承担了过多的事情。</p>\n<ul>\n<li>不要通过参数控制方法内部的处理逻辑</li>\n</ul>\n<p>经常会遇到这样的方法，当参数 a = true 时按 A 逻辑处理，当 参数 a = false 时按 B 逻辑处理。 这样做其实就违反了上一条，让一个方法做了多件事情。这种情况下方法命名都会有问题，无法用名字准确表达方法的功能。这时就应该把两种逻辑拆分到两个方法中。哪怕这样会导致一些重复代码也是值得的。</p>\n<ul>\n<li>当业务逻辑比较复杂时可以考虑进行封装</li>\n</ul>\n<p>当业务逻辑比较复杂需要多个步骤才能完成时，这种情况大多数都可以把这块业务逻辑单独封装为一个类，对外只公布几个入口方法，其它内部逻辑的实现拆分到类中的多个私有方法中。<br />\n比如对用户提交的查询条件进行分解时，涉及时间范围条件，单选条件，多选条件等等，就可以构建一个查询条件解析类，传入客户端提交的原始数据，返回分解后的结构化条件。</p>\n<p>上面这些方法，都可以起到让代码更容易阅读的作用。好的代码和好的文章一样，需要不断打磨推敲，不是一蹴而就的。不过大多数程序员工作压力都比较大，需要加班赶工。这个时候再提打磨推敲代码，就有点何不食肉糜的味道了。希望整个环境能越来越好，大家能少加班，有更多的时间优化重构自己的代码。</p>\n', '如何编写易读的代码', NULL, 4, 1, 67, '2022-07-29 00:45:45', '## 首先，要注意排版\n在写代码时注意排版，保持一致的缩进风格，并利用空行划分段落，可以让代码看起来更整洁，逻辑更清晰。\n\n在一个较复杂的方法中，将方法中各个处理步骤用空行进行分隔，可以让代码具备很好的可读性。如果一个方法中几十行代码完全没有分隔，密密麻麻挤在一起，阅读这段代码会让人感觉像是在看一篇没有标点符号的文章，让人喘过不气来。\n\n下面这段代码，正确使用了空行进行分隔，看起来非常轻松。\n\n合适的空行，让阅读者知道上一个处理步骤已结束，开始下一个处理步骤了。在阅读代码时，就可以按空行跳跃进行查看，快速找到关注的点。\n\n统一的缩进格式会让代码看起来整齐划一，非常清爽。阅读这样的代码时，会让人心情愉悦，频频赞许。\n\n## 其次，让代码具备自描述性\n好的代码应该具备自描述性。正如上面提到的，阅读代码就像是阅读一篇文章，好的文章是不需要一边看内容，一边看下面的脚注来理解的。\n\n在接手一个项目时，被吐槽最多的是代码没有注释。但注释过多也是另一个极端，不应该被提倡。过多的注释也会成为项目的一个负担，每次修改代码时必须要记得同步修改注释，如果忘记修改注释，出现注释和代码不一致的情形，就会让人对注释失去信任。经常出现这样的情况，就会让开发变得越来越不愉快了。\n\n当打算写注释时，先思考一下，这里是否能用代码本身来把逻辑表达出来。在确定这是一种特殊情况，需要交代为何如此处理的背景信息时，才应该写注释。正常情况下，都可以通过方法，变量的命名来描述清楚。\n\n比如下面这样的代码，命名，结构都非常清晰易懂\n\n有时为了想一个好名字也要花上一些时间，但这是值得的。良好的命名可以让代码更加易读。类名，方法名，参数名，变量名都是我们可以利用的载体，可以通过这些名称来把代码逻辑表达出来。\n\n## 最后，可以做的还有很多\n让代码简洁易读并不容易，大道至简，是要花很多心思的，这个话题也不是一篇短文可以讲完的。这里再提供几个小方法，希望可以起到抛砖引玉的作用。\n\n- 一个方法只做一件事情，并保证方法名准确，参数及返回值明确\n\n\n一个方法应尽可能短，非必要不要超过 80 行。当超过时，就需要提醒自己，是不是在方法中承担了过多的事情。\n\n\n- 不要通过参数控制方法内部的处理逻辑\n\n\n经常会遇到这样的方法，当参数 a = true 时按 A 逻辑处理，当 参数 a = false 时按 B 逻辑处理。 这样做其实就违反了上一条，让一个方法做了多件事情。这种情况下方法命名都会有问题，无法用名字准确表达方法的功能。这时就应该把两种逻辑拆分到两个方法中。哪怕这样会导致一些重复代码也是值得的。\n\n\n- 当业务逻辑比较复杂时可以考虑进行封装\n\n\n当业务逻辑比较复杂需要多个步骤才能完成时，这种情况大多数都可以把这块业务逻辑单独封装为一个类，对外只公布几个入口方法，其它内部逻辑的实现拆分到类中的多个私有方法中。\n比如对用户提交的查询条件进行分解时，涉及时间范围条件，单选条件，多选条件等等，就可以构建一个查询条件解析类，传入客户端提交的原始数据，返回分解后的结构化条件。\n\n上面这些方法，都可以起到让代码更容易阅读的作用。好的代码和好的文章一样，需要不断打磨推敲，不是一蹴而就的。不过大多数程序员工作压力都比较大，需要加班赶工。这个时候再提打磨推敲代码，就有点何不食肉糜的味道了。希望整个环境能越来越好，大家能少加班，有更多的时间优化重构自己的代码。\n', '代码进阶，我已经进阶了，你呢？', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659021038000.jpg');

-- ----------------------------
-- Table structure for classify
-- ----------------------------
DROP TABLE IF EXISTS `classify`;
CREATE TABLE `classify`  (
  `article_id` int(0) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `label_id` int(0) NOT NULL COMMENT '标签id',
  PRIMARY KEY (`article_id`, `label_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 135 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of classify
-- ----------------------------
INSERT INTO `classify` VALUES (26, 2);
INSERT INTO `classify` VALUES (26, 3);
INSERT INTO `classify` VALUES (27, 1);
INSERT INTO `classify` VALUES (28, 1);
INSERT INTO `classify` VALUES (29, 5);
INSERT INTO `classify` VALUES (29, 6);
INSERT INTO `classify` VALUES (62, 1);
INSERT INTO `classify` VALUES (62, 2);
INSERT INTO `classify` VALUES (63, 1);
INSERT INTO `classify` VALUES (63, 2);
INSERT INTO `classify` VALUES (64, 1);
INSERT INTO `classify` VALUES (65, 1);
INSERT INTO `classify` VALUES (66, 1);
INSERT INTO `classify` VALUES (67, 1);
INSERT INTO `classify` VALUES (68, 1);
INSERT INTO `classify` VALUES (68, 5);
INSERT INTO `classify` VALUES (69, 1);
INSERT INTO `classify` VALUES (69, 5);
INSERT INTO `classify` VALUES (70, 5);
INSERT INTO `classify` VALUES (71, 5);
INSERT INTO `classify` VALUES (72, 5);
INSERT INTO `classify` VALUES (73, 5);
INSERT INTO `classify` VALUES (74, 5);
INSERT INTO `classify` VALUES (75, 5);
INSERT INTO `classify` VALUES (76, 5);
INSERT INTO `classify` VALUES (77, 5);
INSERT INTO `classify` VALUES (78, 1);
INSERT INTO `classify` VALUES (78, 5);
INSERT INTO `classify` VALUES (79, 1);
INSERT INTO `classify` VALUES (79, 5);
INSERT INTO `classify` VALUES (80, 1);
INSERT INTO `classify` VALUES (80, 5);
INSERT INTO `classify` VALUES (81, 1);
INSERT INTO `classify` VALUES (81, 5);
INSERT INTO `classify` VALUES (82, 1);
INSERT INTO `classify` VALUES (82, 5);
INSERT INTO `classify` VALUES (83, 1);
INSERT INTO `classify` VALUES (83, 5);
INSERT INTO `classify` VALUES (84, 1);
INSERT INTO `classify` VALUES (84, 5);
INSERT INTO `classify` VALUES (85, 4);
INSERT INTO `classify` VALUES (85, 5);
INSERT INTO `classify` VALUES (86, 4);
INSERT INTO `classify` VALUES (86, 5);
INSERT INTO `classify` VALUES (87, 4);
INSERT INTO `classify` VALUES (87, 5);
INSERT INTO `classify` VALUES (88, 4);
INSERT INTO `classify` VALUES (88, 5);
INSERT INTO `classify` VALUES (89, 2);
INSERT INTO `classify` VALUES (89, 3);
INSERT INTO `classify` VALUES (90, 2);
INSERT INTO `classify` VALUES (90, 3);
INSERT INTO `classify` VALUES (91, 2);
INSERT INTO `classify` VALUES (91, 3);
INSERT INTO `classify` VALUES (92, 2);
INSERT INTO `classify` VALUES (92, 4);
INSERT INTO `classify` VALUES (93, 2);
INSERT INTO `classify` VALUES (93, 4);
INSERT INTO `classify` VALUES (94, 2);
INSERT INTO `classify` VALUES (94, 4);
INSERT INTO `classify` VALUES (95, 2);
INSERT INTO `classify` VALUES (95, 4);
INSERT INTO `classify` VALUES (96, 2);
INSERT INTO `classify` VALUES (96, 4);
INSERT INTO `classify` VALUES (97, 2);
INSERT INTO `classify` VALUES (97, 4);
INSERT INTO `classify` VALUES (98, 2);
INSERT INTO `classify` VALUES (98, 4);
INSERT INTO `classify` VALUES (99, 2);
INSERT INTO `classify` VALUES (99, 4);
INSERT INTO `classify` VALUES (100, 2);
INSERT INTO `classify` VALUES (100, 4);
INSERT INTO `classify` VALUES (101, 2);
INSERT INTO `classify` VALUES (101, 4);
INSERT INTO `classify` VALUES (102, 3);
INSERT INTO `classify` VALUES (102, 4);
INSERT INTO `classify` VALUES (103, 3);
INSERT INTO `classify` VALUES (103, 4);
INSERT INTO `classify` VALUES (104, 3);
INSERT INTO `classify` VALUES (104, 4);
INSERT INTO `classify` VALUES (105, 3);
INSERT INTO `classify` VALUES (105, 4);
INSERT INTO `classify` VALUES (106, 5);
INSERT INTO `classify` VALUES (107, 1);
INSERT INTO `classify` VALUES (107, 5);
INSERT INTO `classify` VALUES (108, 5);
INSERT INTO `classify` VALUES (109, 3);
INSERT INTO `classify` VALUES (110, 5);
INSERT INTO `classify` VALUES (111, 5);
INSERT INTO `classify` VALUES (112, 5);
INSERT INTO `classify` VALUES (113, 1);
INSERT INTO `classify` VALUES (114, 1);
INSERT INTO `classify` VALUES (115, 1);
INSERT INTO `classify` VALUES (116, 2);
INSERT INTO `classify` VALUES (117, 4);
INSERT INTO `classify` VALUES (118, 4);
INSERT INTO `classify` VALUES (119, 4);
INSERT INTO `classify` VALUES (120, 5);
INSERT INTO `classify` VALUES (121, 5);
INSERT INTO `classify` VALUES (122, 5);
INSERT INTO `classify` VALUES (123, 1);
INSERT INTO `classify` VALUES (123, 5);
INSERT INTO `classify` VALUES (124, 5);
INSERT INTO `classify` VALUES (125, 5);
INSERT INTO `classify` VALUES (126, 2);
INSERT INTO `classify` VALUES (127, 1);
INSERT INTO `classify` VALUES (128, 1);
INSERT INTO `classify` VALUES (129, 1);
INSERT INTO `classify` VALUES (130, 5);
INSERT INTO `classify` VALUES (131, 2);
INSERT INTO `classify` VALUES (131, 5);
INSERT INTO `classify` VALUES (132, 2);
INSERT INTO `classify` VALUES (133, 2);
INSERT INTO `classify` VALUES (134, 2);

-- ----------------------------
-- Table structure for click
-- ----------------------------
DROP TABLE IF EXISTS `click`;
CREATE TABLE `click`  (
  `user_id` int(0) NOT NULL COMMENT '用户id',
  `clicked_id` int(0) NOT NULL COMMENT '被浏览用户id',
  `article_id` int(0) NOT NULL COMMENT '被浏览文章id',
  `time` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '时间',
  PRIMARY KEY (`user_id`, `clicked_id`, `article_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of click
-- ----------------------------
INSERT INTO `click` VALUES (1, 3, 2, '2022-07-14 13:36:59');
INSERT INTO `click` VALUES (2, 3, 2, '2022-07-25 13:37:10');
INSERT INTO `click` VALUES (4, 3, 2, '2022-07-25 13:37:18');

-- ----------------------------
-- Table structure for collect
-- ----------------------------
DROP TABLE IF EXISTS `collect`;
CREATE TABLE `collect`  (
  `user_id` int(0) NOT NULL COMMENT '用户Id',
  `collected_id` int(0) NOT NULL COMMENT '被收藏用户id',
  `article_id` int(0) NOT NULL COMMENT '被收藏文章id',
  `time` datetime(0) NULL DEFAULT NULL COMMENT '时间',
  `status` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '1' COMMENT '1为正常,0为取消',
  PRIMARY KEY (`user_id`, `collected_id`, `article_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of collect
-- ----------------------------
INSERT INTO `collect` VALUES (1, 2, 1, '2022-07-28 21:13:34', '1');
INSERT INTO `collect` VALUES (1, 3, 26, '2022-07-25 10:59:53', '1');
INSERT INTO `collect` VALUES (1, 3, 27, '2022-07-27 13:23:42', '1');
INSERT INTO `collect` VALUES (1, 3, 64, '2022-07-28 16:24:36', '1');
INSERT INTO `collect` VALUES (1, 4, 134, '2022-07-29 00:11:59', '1');
INSERT INTO `collect` VALUES (1, 6, 89, '2022-07-28 16:30:57', '0');
INSERT INTO `collect` VALUES (2, 3, 3, '2022-07-11 14:45:40', '1');
INSERT INTO `collect` VALUES (3, 2, 1, '2022-07-28 21:01:05', '1');
INSERT INTO `collect` VALUES (3, 3, 28, '2022-07-28 00:42:37', '0');
INSERT INTO `collect` VALUES (3, 3, 55, '2022-07-27 16:20:55', '0');
INSERT INTO `collect` VALUES (3, 3, 64, '2022-07-28 21:08:49', '1');
INSERT INTO `collect` VALUES (3, 6, 105, '2022-07-27 17:41:20', '0');
INSERT INTO `collect` VALUES (4, 5, 2, '2022-07-27 13:51:24', '1');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `comment_id` int(0) NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `from_id` int(0) NOT NULL COMMENT '评论人id',
  `time` datetime(0) NULL DEFAULT NULL COMMENT '发表日期',
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '内容',
  `article_id` int(0) NOT NULL COMMENT '评论文章id',
  `father_id` int(0) NULL DEFAULT NULL COMMENT '父评论Id',
  `root_id` int(0) NULL DEFAULT NULL COMMENT '根评论id',
  `status` int(0) NULL DEFAULT 1 COMMENT '状态，1为正常，0为删除',
  `sum_like` int(0) NULL DEFAULT NULL COMMENT '点赞量',
  PRIMARY KEY (`comment_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 102 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (1, 3, '2019-09-16 18:43:00', '你好呀', 1, NULL, NULL, 1, 1);
INSERT INTO `comment` VALUES (2, 1, '2019-09-16 18:43:00', '你好', 1, 1, 1, 1, 1);
INSERT INTO `comment` VALUES (3, 3, '2019-09-16 18:43:00', '好', 1, 2, 1, 1, 0);
INSERT INTO `comment` VALUES (4, 3, '2019-09-16 18:43:00', '哦', 1, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (5, 3, '2022-07-25 18:43:00', '这是一个新评论', 2, NULL, NULL, 1, NULL);
INSERT INTO `comment` VALUES (35, 1, '2022-07-25 21:47:38', '222', 1, 3, 1, NULL, 1);
INSERT INTO `comment` VALUES (36, 1, '2022-07-25 21:54:55', '22222', 1, 4, 4, NULL, 0);
INSERT INTO `comment` VALUES (37, 1, '2022-07-25 21:55:02', '2', 1, 3, 1, NULL, 0);
INSERT INTO `comment` VALUES (39, 1, '2022-07-25 22:08:02', '222', 28, NULL, NULL, NULL, 0);
INSERT INTO `comment` VALUES (40, 1, '2022-07-25 22:09:20', '222', 28, NULL, NULL, NULL, 1);
INSERT INTO `comment` VALUES (41, 1, '2022-07-25 22:09:39', '222', 28, NULL, NULL, NULL, 1);
INSERT INTO `comment` VALUES (42, 1, '2022-07-25 22:10:57', '333', 43, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (43, 1, '2022-07-25 22:11:02', '22', 43, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (44, 1, '2022-07-26 15:35:34', '2222', 1, 1, 1, 1, 0);
INSERT INTO `comment` VALUES (45, 1, '2022-07-26 15:40:00', '333', 1, 4, 4, 1, 0);
INSERT INTO `comment` VALUES (46, 1, '2022-07-26 15:40:05', '444', 1, 4, 4, 1, 0);
INSERT INTO `comment` VALUES (47, 1, '2022-07-26 17:52:52', 'dadfadf', 1, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (48, 1, '2022-07-26 17:55:39', '111', 1, 3, 1, 1, 1);
INSERT INTO `comment` VALUES (49, 1, '2022-07-26 17:57:52', '222', 55, NULL, NULL, 1, 1);
INSERT INTO `comment` VALUES (50, 1, '2022-07-26 18:42:09', '博主写的太有意思了', 27, NULL, NULL, 1, 1);
INSERT INTO `comment` VALUES (51, 1, '2022-07-26 19:13:23', '111', 1, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (52, 1, '2022-07-26 19:22:54', '曹奥广是呆瓜', 1, NULL, NULL, 1, 1);
INSERT INTO `comment` VALUES (53, 1, '2022-07-26 19:23:31', '123', 1, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (54, 1, '2022-07-26 19:45:12', 'test', 67, NULL, NULL, NULL, 0);
INSERT INTO `comment` VALUES (55, 3, '2022-07-26 22:24:30', '123', 1, 52, 52, 1, 1);
INSERT INTO `comment` VALUES (56, 3, '2022-07-26 23:12:47', '123456', 26, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (57, 3, '2022-07-26 23:12:52', '15641\n', 26, 56, 56, 1, 1);
INSERT INTO `comment` VALUES (58, 3, '2022-07-26 23:17:21', '123', 1, 35, 1, 1, 0);
INSERT INTO `comment` VALUES (59, 3, '2022-07-26 23:17:31', '好', 1, 3, 1, 1, 0);
INSERT INTO `comment` VALUES (60, 3, '2022-07-26 23:22:50', '123', 55, 49, 49, 1, 0);
INSERT INTO `comment` VALUES (61, 3, '2022-07-26 23:23:04', '123', 55, 60, 49, 1, 0);
INSERT INTO `comment` VALUES (62, 3, '2022-07-26 23:23:12', '123', 55, 61, 49, 1, 0);
INSERT INTO `comment` VALUES (63, 3, '2022-07-26 23:30:21', '123', 1, 1, 1, 1, 0);
INSERT INTO `comment` VALUES (64, 3, '2022-07-26 23:30:56', '自己', 64, NULL, NULL, NULL, 1);
INSERT INTO `comment` VALUES (65, 3, '2022-07-26 23:31:01', '评论自己', 64, 64, 64, NULL, 1);
INSERT INTO `comment` VALUES (87, 3, '2022-07-27 22:22:35', '123', 96, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (88, 1, '2022-07-28 16:21:27', '皮卡丘不错啊', 64, 64, 64, 1, 1);
INSERT INTO `comment` VALUES (89, 1, '2022-07-28 16:22:10', '博主讲的很不错', 1, 1, 1, 1, 0);
INSERT INTO `comment` VALUES (90, 1, '2022-07-28 16:23:02', '博主讲的很不错', 1, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (91, 1, '2022-07-28 16:23:50', '这是啥？', 98, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (92, 1, '2022-07-28 16:30:05', '啊，对对对', 108, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (93, 1, '2022-07-28 16:31:45', '这是啥意识', 89, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (94, 1, '2022-07-28 16:31:42', '这是啥意识', 89, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (95, 1, '2022-07-28 17:05:04', '赞', 110, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (96, 3, '2022-07-28 17:47:31', '赞', 114, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (97, 3, '2022-07-28 20:11:34', '123', 1, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (98, 1, '2022-07-28 21:08:00', '赞', 112, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (99, 4, '2022-07-28 22:48:44', '可以啊，小兄弟儿', 110, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (100, 4, '2022-07-28 22:49:03', '不错不错', 110, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (101, 4, '2022-07-28 22:55:11', '赞', 118, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (102, 1, '2022-07-28 23:15:40', '赞，讲的很详细', 130, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (103, 1, '2022-07-28 23:15:56', '赞，讲的很详细', 131, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (104, 6, '2022-07-28 23:17:10', '赞，讲的很详细', 133, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (105, 6, '2022-07-28 23:17:19', '赞，讲的很详细', 131, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (106, 6, '2022-07-28 23:18:37', '赞，讲的很详细', 134, NULL, NULL, 1, 1);
INSERT INTO `comment` VALUES (107, 6, '2022-07-28 23:18:43', '赞，讲的很详细', 117, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (108, 1, '2022-07-28 23:28:37', 'dgrdf', 128, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (109, 101, '2022-07-29 00:04:06', '非常实用', 134, NULL, NULL, 1, 1);
INSERT INTO `comment` VALUES (110, 101, '2022-07-29 00:04:22', '同感', 134, 106, 106, 1, 1);
INSERT INTO `comment` VALUES (111, 101, '2022-07-29 00:04:39', '确实', 134, 106, 106, 1, 0);
INSERT INTO `comment` VALUES (112, 1, '2022-07-29 00:26:08', 'zan', 134, NULL, NULL, 1, 0);
INSERT INTO `comment` VALUES (113, 1, '2022-07-29 00:46:17', '哈哈哈', 27, NULL, NULL, 1, 0);

-- ----------------------------
-- Table structure for commentlike
-- ----------------------------
DROP TABLE IF EXISTS `commentlike`;
CREATE TABLE `commentlike`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int(0) NULL DEFAULT NULL COMMENT '用户id',
  `comment_id` int(0) NULL DEFAULT NULL COMMENT '评论id',
  `time` date NULL DEFAULT NULL COMMENT '点赞评论时间',
  `article_id` int(0) NULL DEFAULT NULL COMMENT '文章id',
  `liked_id` int(0) NULL DEFAULT NULL COMMENT '被点赞用户id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 61 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of commentlike
-- ----------------------------
INSERT INTO `commentlike` VALUES (34, 1, 1, '2022-07-26', 1, 3);
INSERT INTO `commentlike` VALUES (35, 1, 2, '2022-07-26', 1, 1);
INSERT INTO `commentlike` VALUES (36, 1, 48, '2022-07-26', 1, 1);
INSERT INTO `commentlike` VALUES (38, 1, 41, '2022-07-26', 28, 1);
INSERT INTO `commentlike` VALUES (39, 1, 40, '2022-07-26', 28, 1);
INSERT INTO `commentlike` VALUES (41, 1, 49, '2022-07-26', 55, 1);
INSERT INTO `commentlike` VALUES (45, 1, 35, '2022-07-26', 1, 1);
INSERT INTO `commentlike` VALUES (46, 1, 50, '2022-07-26', 27, 1);
INSERT INTO `commentlike` VALUES (48, 3, 57, '2022-07-26', 26, 3);
INSERT INTO `commentlike` VALUES (52, 1, 52, '2022-07-26', 1, 1);
INSERT INTO `commentlike` VALUES (53, 1, 55, '2022-07-26', 1, 3);
INSERT INTO `commentlike` VALUES (58, 1, 64, '2022-07-28', 64, 3);
INSERT INTO `commentlike` VALUES (59, 1, 65, '2022-07-28', 64, 3);
INSERT INTO `commentlike` VALUES (60, 1, 88, '2022-07-28', 64, 1);
INSERT INTO `commentlike` VALUES (61, 101, 106, '2022-07-29', 134, 6);
INSERT INTO `commentlike` VALUES (62, 101, 110, '2022-07-29', 134, 101);
INSERT INTO `commentlike` VALUES (64, 101, 109, '2022-07-29', 134, 101);

-- ----------------------------
-- Table structure for draft
-- ----------------------------
DROP TABLE IF EXISTS `draft`;
CREATE TABLE `draft`  (
  `article_id` int(0) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `user_id` int(0) NOT NULL COMMENT '发布人',
  `create_time` datetime(0) NOT NULL COMMENT '发布日期',
  `html_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'html格式文章内容',
  `title` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章标题',
  `edit_time` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '编辑时间',
  `md_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT 'md格式文章内容',
  `summary` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '文章摘要',
  `cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章封面',
  PRIMARY KEY (`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 69 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of draft
-- ----------------------------
INSERT INTO `draft` VALUES (28, 3, '2022-07-25 01:14:40', '<h3><a id=\"_0\"></a>描述如下</h3>\n<ul>\n<li>同时发多个相同的请求，如果第一个请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回</li>\n<li>如果第一个请求失败了，那么接着发编号为2的请求，如果请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回</li>\n<li>如果第二个请求失败了，那么接着发编号为3的请求，如果请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回</li>\n<li><code>...</code>以此递推，直到遇到最坏的情况需要发送最后一个请求</li>\n</ul>\n<blockquote>\n<p>并发： 一个接口请求还处于pending，短时间内就发送相同的请求</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchData</span> (a)  {\n    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;//127.0.0.1:3000/test&#x27;</span>)\n    <span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-keyword\">await</span> data.<span class=\"hljs-title function_\">json</span>();\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(d);\n    <span class=\"hljs-keyword\">return</span> d;\n}\n\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 编号 1</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 3</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 4</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 4</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 5</span>\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-number\">2</span>)\n复制代码\n</code></div></pre>\n<h3><a id=\"cachedAsync_28\"></a>老版本<code>cachedAsync</code></h3>\n<p>我之前使用过<code>vue</code>的缓存函数缓存成功的请求, 实现是这样的。下面的<code>cachedAsync</code>只会缓存成功的请求，如果失败了，直接拉起新的请求。但是如果是上面的并发场景，相同的请求因为无法命中缓存，会出现连续发送三个请求的问题，无法处理这种并发的场景。</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> cachedAsync = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">fn</span>) {\n    <span class=\"hljs-keyword\">const</span> cache = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-literal\">null</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">async</span> str =&gt; {\n        <span class=\"hljs-keyword\">const</span> hit = cache[str];\n        <span class=\"hljs-keyword\">if</span> (hit) {\n            <span class=\"hljs-keyword\">return</span> hit;\n        }\n        <span class=\"hljs-comment\">// 只缓存成功的Promise, 失败直接重新请求</span>\n        <span class=\"hljs-keyword\">return</span> (cache[str] = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fn</span>(str));\n    };\n};\n<span class=\"hljs-keyword\">const</span> fetch2 = <span class=\"hljs-title function_\">cachedAsync</span>(fetchData)\n<span class=\"hljs-title function_\">fetch2</span>(<span class=\"hljs-number\">2</span>);\n<span class=\"hljs-title function_\">fetch2</span>(<span class=\"hljs-number\">2</span>);\n<span class=\"hljs-title function_\">fetch2</span>(<span class=\"hljs-number\">2</span>);\n</code></div></pre>\n', '前端并发10个相同的请求，怎么控制为只发一个请求？', NULL, '### 描述如下\n\n- 同时发多个相同的请求，如果第一个请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回\n- 如果第一个请求失败了，那么接着发编号为2的请求，如果请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回\n- 如果第二个请求失败了，那么接着发编号为3的请求，如果请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回\n- `...`以此递推，直到遇到最坏的情况需要发送最后一个请求\n\n> 并发： 一个接口请求还处于pending，短时间内就发送相同的请求\n\n```js\nasync function fetchData (a)  {\n    const data = await fetch(\'//127.0.0.1:3000/test\')\n    const d = await data.json();\n    console.log(d);\n    return d;\n}\n\nfetchData(2) // 编号 1\nfetchData(2) // 2\nfetchData(2) // 3\nfetchData(2) // 4\nfetchData(2) // 4\nfetchData(2) // 5\nfetchData(2)\nfetchData(2)\n复制代码\n```\n\n### 老版本`cachedAsync`\n\n我之前使用过`vue`的缓存函数缓存成功的请求, 实现是这样的。下面的`cachedAsync`只会缓存成功的请求，如果失败了，直接拉起新的请求。但是如果是上面的并发场景，相同的请求因为无法命中缓存，会出现连续发送三个请求的问题，无法处理这种并发的场景。\n\n```js\nconst cachedAsync = function(fn) {\n    const cache = Object.create(null);\n    return async str => {\n        const hit = cache[str];\n        if (hit) {\n            return hit;\n        }\n        // 只缓存成功的Promise, 失败直接重新请求\n        return (cache[str] = await fn(str));\n    };\n};\nconst fetch2 = cachedAsync(fetchData)\nfetch2(2);\nfetch2(2);\nfetch2(2);\n```\n\n', '描述如下\n同时发多个相同的请求，如果第一个请求成功，那么剩余的请求都不会发出，成功的结果作为剩余请求返回', NULL);
INSERT INTO `draft` VALUES (68, 6, '2022-07-28 19:42:18', '<p>dsf</p>\n', 'gdhg', NULL, 'dsf', NULL, NULL);
INSERT INTO `draft` VALUES (69, 1, '2022-07-29 00:27:08', '<p>xcv,ncxxc,mvbnkjxzcbv,zmxcvhb</p>\n', '测试', NULL, 'xcv,ncxxc,mvbnkjxzcbv,zmxcvhb', NULL, NULL);

-- ----------------------------
-- Table structure for follow
-- ----------------------------
DROP TABLE IF EXISTS `follow`;
CREATE TABLE `follow`  (
  `user_id` int(0) NOT NULL COMMENT '用户id',
  `followed_id` int(0) NOT NULL COMMENT '被关注用户id',
  `time` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '时间',
  `status` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '1' COMMENT '1为关注，0为取关',
  PRIMARY KEY (`user_id`, `followed_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of follow
-- ----------------------------
INSERT INTO `follow` VALUES (1, 2, '2022-07-28 21:12:19', '0');
INSERT INTO `follow` VALUES (1, 3, '2022-07-28 21:02:41', '0');
INSERT INTO `follow` VALUES (2, 3, '2022-07-20 14:56:32', '1');
INSERT INTO `follow` VALUES (3, 1, '2022-07-27 17:51:04', '1');
INSERT INTO `follow` VALUES (3, 2, '2022-07-27 20:42:56', '0');
INSERT INTO `follow` VALUES (3, 4, '2022-07-28 12:19:26', '0');
INSERT INTO `follow` VALUES (5, 3, '2022-07-24 19:20:04', '1');
INSERT INTO `follow` VALUES (6, 3, '2022-07-28 23:17:44', '1');
INSERT INTO `follow` VALUES (7, 8, '2022-07-26 19:07:43', '0');

-- ----------------------------
-- Table structure for label
-- ----------------------------
DROP TABLE IF EXISTS `label`;
CREATE TABLE `label`  (
  `label_id` int(0) NOT NULL AUTO_INCREMENT COMMENT '标签Id',
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标签名',
  PRIMARY KEY (`label_id`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of label
-- ----------------------------
INSERT INTO `label` VALUES (5, '人工智能');
INSERT INTO `label` VALUES (1, '前端');
INSERT INTO `label` VALUES (2, '后端');
INSERT INTO `label` VALUES (4, '数据库');
INSERT INTO `label` VALUES (3, '算法');

-- ----------------------------
-- Table structure for like
-- ----------------------------
DROP TABLE IF EXISTS `like`;
CREATE TABLE `like`  (
  `user_id` int(0) NOT NULL COMMENT '自身id',
  `liked_id` int(0) NOT NULL COMMENT '被赞用户id',
  `article_id` int(0) NOT NULL COMMENT '被赞文章id',
  `time` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '时间',
  `status` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '1' COMMENT '1为正常，0为取消',
  PRIMARY KEY (`user_id`, `liked_id`, `article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of like
-- ----------------------------
INSERT INTO `like` VALUES (1, 1, 110, '2022-07-28 17:04:24', '1');
INSERT INTO `like` VALUES (1, 1, 112, '2022-07-28 21:07:03', '0');
INSERT INTO `like` VALUES (1, 1, 128, '2022-07-28 22:29:23', '1');
INSERT INTO `like` VALUES (1, 2, 130, '2022-07-28 23:15:24', '1');
INSERT INTO `like` VALUES (1, 2, 131, '2022-07-28 23:15:07', '1');
INSERT INTO `like` VALUES (1, 3, 64, '2022-07-28 21:05:56', '1');
INSERT INTO `like` VALUES (1, 4, 117, '2022-07-28 18:24:06', '1');
INSERT INTO `like` VALUES (1, 4, 118, '2022-07-28 18:23:56', '1');
INSERT INTO `like` VALUES (1, 4, 119, '2022-07-28 18:24:00', '1');
INSERT INTO `like` VALUES (1, 4, 132, '2022-07-28 23:15:03', '1');
INSERT INTO `like` VALUES (1, 4, 134, '2022-07-28 23:14:48', '1');
INSERT INTO `like` VALUES (3, 1, 111, '2022-07-28 17:47:53', '1');
INSERT INTO `like` VALUES (3, 2, 1, '2022-07-28 20:11:29', '0');
INSERT INTO `like` VALUES (3, 2, 113, '2022-07-28 17:47:45', '1');
INSERT INTO `like` VALUES (3, 2, 114, '2022-07-28 17:47:21', '1');
INSERT INTO `like` VALUES (3, 3, 26, '2022-07-27 17:23:57', '0');
INSERT INTO `like` VALUES (3, 3, 27, '2022-07-27 17:26:42', '1');
INSERT INTO `like` VALUES (3, 3, 28, '2022-07-28 00:42:35', '1');
INSERT INTO `like` VALUES (3, 3, 64, '2022-07-28 21:08:40', '1');
INSERT INTO `like` VALUES (3, 6, 105, '2022-07-27 17:41:20', '0');
INSERT INTO `like` VALUES (4, 4, 134, '2022-07-28 23:13:46', '1');
INSERT INTO `like` VALUES (6, 1, 128, '2022-07-28 23:16:26', '1');
INSERT INTO `like` VALUES (6, 4, 117, '2022-07-28 23:16:17', '1');
INSERT INTO `like` VALUES (6, 4, 133, '2022-07-28 23:16:36', '1');
INSERT INTO `like` VALUES (6, 4, 134, '2022-07-28 23:16:22', '1');
INSERT INTO `like` VALUES (101, 4, 134, '2022-07-29 00:02:36', '1');

-- ----------------------------
-- Table structure for report
-- ----------------------------
DROP TABLE IF EXISTS `report`;
CREATE TABLE `report`  (
  `report_id` int(0) NOT NULL AUTO_INCREMENT COMMENT '举报编号',
  `user_id` int(0) NOT NULL COMMENT '举报者',
  `article_id` int(0) NOT NULL COMMENT '文章id',
  `reported_id` int(0) NOT NULL COMMENT '被举报者',
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '举报内容',
  `img` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '举报截图',
  `time` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '举报时间',
  `handle` int(1) UNSIGNED ZEROFILL NOT NULL COMMENT '1被处理 0待处理',
  PRIMARY KEY (`report_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of report
-- ----------------------------
INSERT INTO `report` VALUES (1, 3, 64, 3, '123', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1658931601000.jpg', '2022-07-28 18:25:46', 1);
INSERT INTO `report` VALUES (2, 3, 96, 6, '123123123', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1658931741000.jpg', '2022-07-28 18:27:32', 1);

-- ----------------------------
-- Table structure for role
-- ----------------------------
DROP TABLE IF EXISTS `role`;
CREATE TABLE `role`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `role` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of role
-- ----------------------------
INSERT INTO `role` VALUES (1, '超级管理员', 'superAdmin');
INSERT INTO `role` VALUES (2, '管理员', 'admin');
INSERT INTO `role` VALUES (3, '用户', 'user');

-- ----------------------------
-- Table structure for search
-- ----------------------------
DROP TABLE IF EXISTS `search`;
CREATE TABLE `search`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '搜索唯一标识',
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '搜索内容',
  `user_id` int(0) NOT NULL COMMENT '用户id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 36 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of search
-- ----------------------------
INSERT INTO `search` VALUES (6, '123', 3);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `user_id` int(0) NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `userName` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `passWord` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户密码',
  `profile_photo` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户头像',
  `role` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '0' COMMENT '用户身份,1为管理员，0为用户',
  `regist_time` datetime(0) NULL DEFAULT NULL COMMENT '注册时间',
  `email` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱   ',
  `phone` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '电话号码',
  `img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '头像链接',
  `position` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '职位',
  PRIMARY KEY (`user_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 103 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'root', 'root', NULL, '1', NULL, '2768359537@qq.com', NULL, 'https://ae01.alicdn.com/kf/Hd60a3f7c06fd47ae85624badd32ce54dv.jpg', 'cv工程师');
INSERT INTO `user` VALUES (2, 'admin', '123456', NULL, '0', NULL, NULL, NULL, 'https://p9-passport.byteacctimg.com/img/user-avatar/1b4b702f74bede46370020d618fdc14b~300x300.image', 'cv工程师');
INSERT INTO `user` VALUES (3, 'butcher', '123456', NULL, '0', NULL, '150845645@qq.com', '15621057816', 'https://img0.baidu.com/it/u=3990430052,822773136&fm=253&app=138&size=w931&n=0&f=PNG&fmt=auto?sec=1658941200&t=ee24c8d953457cc54c645e3707dc577b', 'cv工程师');
INSERT INTO `user` VALUES (4, '艾哲理', '123456', NULL, '0', NULL, NULL, NULL, 'https://p26-passport.byteacctimg.com/img/user-avatar/894557c5402a2da79a8aec8d5388db44~300x300.image', 'cv工程师');
INSERT INTO `user` VALUES (5, '罗伯特', '123456', NULL, '0', NULL, NULL, NULL, 'https://p6-passport.byteacctimg.com/img/user-avatar/a8309022fd7d51c2d9cc30cfa35123d1~300x300.image', 'cv工程师');
INSERT INTO `user` VALUES (6, 'user', 'pass', NULL, '0', NULL, NULL, NULL, 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1658839491000.jpg', NULL);
INSERT INTO `user` VALUES (7, 'fan', '123456', NULL, '0', NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (8, 'adsfg', '123456', NULL, '0', NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (10, 'token', '$2a$10$h1UBWj.zOyrukmn6opcIheMr0jRtfty8fguoKFqrF0h//xyrERoPG', NULL, '0', NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (101, 'admin123', 'admin', NULL, '1', NULL, '504116598@qq.com', '15940950424', 'https://our-blog.oss-cn-qingdao.aliyuncs.com/articleImg/1659024187000.jpg', 'cv工程师1');

-- ----------------------------
-- Table structure for user_role
-- ----------------------------
DROP TABLE IF EXISTS `user_role`;
CREATE TABLE `user_role`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `user_id` int(0) NULL DEFAULT NULL,
  `role_id` int(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user_role
-- ----------------------------
INSERT INTO `user_role` VALUES (1, 1, 1);
INSERT INTO `user_role` VALUES (2, 1, 2);
INSERT INTO `user_role` VALUES (3, 1, 3);
INSERT INTO `user_role` VALUES (4, 3, 3);

SET FOREIGN_KEY_CHECKS = 1;
